//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.3.1.7705
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.3.1.7705 EcmaScript.g 2014-01-02 10:22:18

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162


using System;
using System.Text;
using System.Globalization;
using Jint.Ast;


using System.Collections.Generic;
using Antlr.Runtime;

namespace  Jint.Parser 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.3.1.7705")]
internal partial class EcmaScriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ABSTRACT", "ADD", "ADDASS", "AND", "ANDASS", "ARGS", "ARRAY", "ASSIGN", "BLOCK", "BOOLEAN", "BREAK", "BSLASH", "BYFIELD", "BYINDEX", "BYTE", "BackslashSequence", "CALL", "CASE", "CATCH", "CEXPR", "CHAR", "CLASS", "COLON", "COMMA", "CONST", "CONTINUE", "CR", "CharacterEscapeSequence", "DEBUGGER", "DEC", "DEFAULT", "DELETE", "DIV", "DIVASS", "DO", "DOT", "DOUBLE", "DQUOTE", "DecimalDigit", "DecimalIntegerLiteral", "DecimalLiteral", "ELSE", "ENUM", "EOL", "EQ", "EXPORT", "EXPR", "EXTENDS", "EscapeSequence", "ExponentPart", "FALSE", "FF", "FINAL", "FINALLY", "FLOAT", "FOR", "FORITER", "FORSTEP", "FUNCTION", "GOTO", "GT", "GTE", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "IF", "IMPLEMENTS", "IMPORT", "IN", "INC", "INSTANCEOF", "INT", "INTERFACE", "INV", "ITEM", "Identifier", "IdentifierNameASCIIStart", "IdentifierPart", "IdentifierStartASCII", "LABELLED", "LAND", "LBRACE", "LBRACK", "LF", "LONG", "LOR", "LPAREN", "LS", "LT", "LTE", "LineTerminator", "MOD", "MODASS", "MUL", "MULASS", "MultiLineComment", "NAMEDVALUE", "NATIVE", "NBSP", "NEG", "NEQ", "NEW", "NOT", "NSAME", "NULL", "OBJECT", "OR", "ORASS", "OctalDigit", "OctalEscapeSequence", "OctalIntegerLiteral", "PACKAGE", "PAREXPR", "PDEC", "PINC", "POS", "PRIVATE", "PROTECTED", "PS", "PUBLIC", "QUE", "RBRACE", "RBRACK", "REF", "RETURN", "RPAREN", "RegularExpressionChar", "RegularExpressionFirstChar", "RegularExpressionLiteral", "SAME", "SEMIC", "SHL", "SHLASS", "SHORT", "SHR", "SHRASS", "SHU", "SHUASS", "SP", "SQUOTE", "STATIC", "SUB", "SUBASS", "SUPER", "SWITCH", "SYNCHRONIZED", "SingleLineComment", "StringLiteral", "TAB", "THIS", "THROW", "THROWS", "TRANSIENT", "TRUE", "TRY", "TYPEOF", "USP", "UnicodeEscapeSequence", "VAR", "VOID", "VOLATILE", "VT", "WHILE", "WITH", "WhiteSpace", "XOR", "XORASS", "ZeroToThree"
	};
	public const int EOF=-1;
	public const int ABSTRACT=4;
	public const int ADD=5;
	public const int ADDASS=6;
	public const int AND=7;
	public const int ANDASS=8;
	public const int ARGS=9;
	public const int ARRAY=10;
	public const int ASSIGN=11;
	public const int BLOCK=12;
	public const int BOOLEAN=13;
	public const int BREAK=14;
	public const int BSLASH=15;
	public const int BYFIELD=16;
	public const int BYINDEX=17;
	public const int BYTE=18;
	public const int BackslashSequence=19;
	public const int CALL=20;
	public const int CASE=21;
	public const int CATCH=22;
	public const int CEXPR=23;
	public const int CHAR=24;
	public const int CLASS=25;
	public const int COLON=26;
	public const int COMMA=27;
	public const int CONST=28;
	public const int CONTINUE=29;
	public const int CR=30;
	public const int CharacterEscapeSequence=31;
	public const int DEBUGGER=32;
	public const int DEC=33;
	public const int DEFAULT=34;
	public const int DELETE=35;
	public const int DIV=36;
	public const int DIVASS=37;
	public const int DO=38;
	public const int DOT=39;
	public const int DOUBLE=40;
	public const int DQUOTE=41;
	public const int DecimalDigit=42;
	public const int DecimalIntegerLiteral=43;
	public const int DecimalLiteral=44;
	public const int ELSE=45;
	public const int ENUM=46;
	public const int EOL=47;
	public const int EQ=48;
	public const int EXPORT=49;
	public const int EXPR=50;
	public const int EXTENDS=51;
	public const int EscapeSequence=52;
	public const int ExponentPart=53;
	public const int FALSE=54;
	public const int FF=55;
	public const int FINAL=56;
	public const int FINALLY=57;
	public const int FLOAT=58;
	public const int FOR=59;
	public const int FORITER=60;
	public const int FORSTEP=61;
	public const int FUNCTION=62;
	public const int GOTO=63;
	public const int GT=64;
	public const int GTE=65;
	public const int HexDigit=66;
	public const int HexEscapeSequence=67;
	public const int HexIntegerLiteral=68;
	public const int IF=69;
	public const int IMPLEMENTS=70;
	public const int IMPORT=71;
	public const int IN=72;
	public const int INC=73;
	public const int INSTANCEOF=74;
	public const int INT=75;
	public const int INTERFACE=76;
	public const int INV=77;
	public const int ITEM=78;
	public const int Identifier=79;
	public const int IdentifierNameASCIIStart=80;
	public const int IdentifierPart=81;
	public const int IdentifierStartASCII=82;
	public const int LABELLED=83;
	public const int LAND=84;
	public const int LBRACE=85;
	public const int LBRACK=86;
	public const int LF=87;
	public const int LONG=88;
	public const int LOR=89;
	public const int LPAREN=90;
	public const int LS=91;
	public const int LT=92;
	public const int LTE=93;
	public const int LineTerminator=94;
	public const int MOD=95;
	public const int MODASS=96;
	public const int MUL=97;
	public const int MULASS=98;
	public const int MultiLineComment=99;
	public const int NAMEDVALUE=100;
	public const int NATIVE=101;
	public const int NBSP=102;
	public const int NEG=103;
	public const int NEQ=104;
	public const int NEW=105;
	public const int NOT=106;
	public const int NSAME=107;
	public const int NULL=108;
	public const int OBJECT=109;
	public const int OR=110;
	public const int ORASS=111;
	public const int OctalDigit=112;
	public const int OctalEscapeSequence=113;
	public const int OctalIntegerLiteral=114;
	public const int PACKAGE=115;
	public const int PAREXPR=116;
	public const int PDEC=117;
	public const int PINC=118;
	public const int POS=119;
	public const int PRIVATE=120;
	public const int PROTECTED=121;
	public const int PS=122;
	public const int PUBLIC=123;
	public const int QUE=124;
	public const int RBRACE=125;
	public const int RBRACK=126;
	public const int REF=127;
	public const int RETURN=128;
	public const int RPAREN=129;
	public const int RegularExpressionChar=130;
	public const int RegularExpressionFirstChar=131;
	public const int RegularExpressionLiteral=132;
	public const int SAME=133;
	public const int SEMIC=134;
	public const int SHL=135;
	public const int SHLASS=136;
	public const int SHORT=137;
	public const int SHR=138;
	public const int SHRASS=139;
	public const int SHU=140;
	public const int SHUASS=141;
	public const int SP=142;
	public const int SQUOTE=143;
	public const int STATIC=144;
	public const int SUB=145;
	public const int SUBASS=146;
	public const int SUPER=147;
	public const int SWITCH=148;
	public const int SYNCHRONIZED=149;
	public const int SingleLineComment=150;
	public const int StringLiteral=151;
	public const int TAB=152;
	public const int THIS=153;
	public const int THROW=154;
	public const int THROWS=155;
	public const int TRANSIENT=156;
	public const int TRUE=157;
	public const int TRY=158;
	public const int TYPEOF=159;
	public const int USP=160;
	public const int UnicodeEscapeSequence=161;
	public const int VAR=162;
	public const int VOID=163;
	public const int VOLATILE=164;
	public const int VT=165;
	public const int WHILE=166;
	public const int WITH=167;
	public const int WhiteSpace=168;
	public const int XOR=169;
	public const int XORASS=170;
	public const int ZeroToThree=171;

	// delegates
	// delegators

	public EcmaScriptParser( ITokenStream input )
		: this( input, new RecognizerSharedState() )
	{
	}
	public EcmaScriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
		

	public override string[] TokenNames { get { return EcmaScriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "EcmaScript.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules

	partial void EnterRule_token();
	partial void LeaveRule_token();

	// $ANTLR start "token"
	// EcmaScript.g:323:1: token : ( reservedWord | Identifier | punctuator | numericLiteral | StringLiteral );
	[GrammarRule("token")]
	private void token()
	{
		EnterRule_token();
		EnterRule("token", 1);
		TraceIn("token", 1);
		try { DebugEnterRule(GrammarFileName, "token");
		DebugLocation(323, 1);
		try
		{
			// EcmaScript.g:324:2: ( reservedWord | Identifier | punctuator | numericLiteral | StringLiteral )
			int alt1=5;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case ABSTRACT:
			case BOOLEAN:
			case BREAK:
			case BYTE:
			case CASE:
			case CATCH:
			case CHAR:
			case CLASS:
			case CONST:
			case CONTINUE:
			case DEBUGGER:
			case DEFAULT:
			case DELETE:
			case DO:
			case DOUBLE:
			case ELSE:
			case ENUM:
			case EXPORT:
			case EXTENDS:
			case FALSE:
			case FINAL:
			case FINALLY:
			case FLOAT:
			case FOR:
			case FUNCTION:
			case GOTO:
			case IF:
			case IMPLEMENTS:
			case IMPORT:
			case IN:
			case INSTANCEOF:
			case INT:
			case INTERFACE:
			case LONG:
			case NATIVE:
			case NEW:
			case NULL:
			case PACKAGE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case RETURN:
			case SHORT:
			case STATIC:
			case SUPER:
			case SWITCH:
			case SYNCHRONIZED:
			case THIS:
			case THROW:
			case THROWS:
			case TRANSIENT:
			case TRUE:
			case TRY:
			case TYPEOF:
			case VAR:
			case VOID:
			case VOLATILE:
			case WHILE:
			case WITH:
				{
				alt1 = 1;
				}
				break;
			case Identifier:
				{
				alt1 = 2;
				}
				break;
			case ADD:
			case ADDASS:
			case AND:
			case ANDASS:
			case ASSIGN:
			case COLON:
			case COMMA:
			case DEC:
			case DIV:
			case DIVASS:
			case DOT:
			case EQ:
			case GT:
			case GTE:
			case INC:
			case INV:
			case LAND:
			case LBRACE:
			case LBRACK:
			case LOR:
			case LPAREN:
			case LT:
			case LTE:
			case MOD:
			case MODASS:
			case MUL:
			case MULASS:
			case NEQ:
			case NOT:
			case NSAME:
			case OR:
			case ORASS:
			case QUE:
			case RBRACE:
			case RBRACK:
			case RPAREN:
			case SAME:
			case SEMIC:
			case SHL:
			case SHLASS:
			case SHR:
			case SHRASS:
			case SHU:
			case SHUASS:
			case SUB:
			case SUBASS:
			case XOR:
			case XORASS:
				{
				alt1 = 3;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt1 = 4;
				}
				break;
			case StringLiteral:
				{
				alt1 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:324:4: reservedWord
				{
				DebugLocation(324, 4);
				PushFollow(Follow._reservedWord_in_token1792);
				reservedWord();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:325:4: Identifier
				{
				DebugLocation(325, 4);
				Match(input,Identifier,Follow._Identifier_in_token1797); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:326:4: punctuator
				{
				DebugLocation(326, 4);
				PushFollow(Follow._punctuator_in_token1802);
				punctuator();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:327:4: numericLiteral
				{
				DebugLocation(327, 4);
				PushFollow(Follow._numericLiteral_in_token1807);
				numericLiteral();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// EcmaScript.g:328:4: StringLiteral
				{
				DebugLocation(328, 4);
				Match(input,StringLiteral,Follow._StringLiteral_in_token1812); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("token", 1);
			LeaveRule("token", 1);
			LeaveRule_token();
		}
		DebugLocation(329, 1);
		} finally { DebugExitRule(GrammarFileName, "token"); }
		return;

	}
	// $ANTLR end "token"


	partial void EnterRule_reservedWord();
	partial void LeaveRule_reservedWord();

	// $ANTLR start "reservedWord"
	// EcmaScript.g:333:1: reservedWord : ( keyword | futureReservedWord | NULL | booleanLiteral );
	[GrammarRule("reservedWord")]
	private void reservedWord()
	{
		EnterRule_reservedWord();
		EnterRule("reservedWord", 2);
		TraceIn("reservedWord", 2);
		try { DebugEnterRule(GrammarFileName, "reservedWord");
		DebugLocation(333, 1);
		try
		{
			// EcmaScript.g:334:2: ( keyword | futureReservedWord | NULL | booleanLiteral )
			int alt2=4;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case BREAK:
			case CASE:
			case CATCH:
			case CONTINUE:
			case DEFAULT:
			case DELETE:
			case DO:
			case ELSE:
			case FINALLY:
			case FOR:
			case FUNCTION:
			case IF:
			case IN:
			case INSTANCEOF:
			case NEW:
			case RETURN:
			case SWITCH:
			case THIS:
			case THROW:
			case TRY:
			case TYPEOF:
			case VAR:
			case VOID:
			case WHILE:
			case WITH:
				{
				alt2 = 1;
				}
				break;
			case ABSTRACT:
			case BOOLEAN:
			case BYTE:
			case CHAR:
			case CLASS:
			case CONST:
			case DEBUGGER:
			case DOUBLE:
			case ENUM:
			case EXPORT:
			case EXTENDS:
			case FINAL:
			case FLOAT:
			case GOTO:
			case IMPLEMENTS:
			case IMPORT:
			case INT:
			case INTERFACE:
			case LONG:
			case NATIVE:
			case PACKAGE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SHORT:
			case STATIC:
			case SUPER:
			case SYNCHRONIZED:
			case THROWS:
			case TRANSIENT:
			case VOLATILE:
				{
				alt2 = 2;
				}
				break;
			case NULL:
				{
				alt2 = 3;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt2 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:334:4: keyword
				{
				DebugLocation(334, 4);
				PushFollow(Follow._keyword_in_reservedWord1825);
				keyword();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:335:4: futureReservedWord
				{
				DebugLocation(335, 4);
				PushFollow(Follow._futureReservedWord_in_reservedWord1830);
				futureReservedWord();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:336:4: NULL
				{
				DebugLocation(336, 4);
				Match(input,NULL,Follow._NULL_in_reservedWord1835); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:337:4: booleanLiteral
				{
				DebugLocation(337, 4);
				PushFollow(Follow._booleanLiteral_in_reservedWord1840);
				booleanLiteral();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("reservedWord", 2);
			LeaveRule("reservedWord", 2);
			LeaveRule_reservedWord();
		}
		DebugLocation(338, 1);
		} finally { DebugExitRule(GrammarFileName, "reservedWord"); }
		return;

	}
	// $ANTLR end "reservedWord"


	partial void EnterRule_keyword();
	partial void LeaveRule_keyword();

	// $ANTLR start "keyword"
	// EcmaScript.g:344:1: keyword : ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH );
	[GrammarRule("keyword")]
	private void keyword()
	{
		EnterRule_keyword();
		EnterRule("keyword", 3);
		TraceIn("keyword", 3);
		try { DebugEnterRule(GrammarFileName, "keyword");
		DebugLocation(344, 1);
		try
		{
			// EcmaScript.g:345:2: ( BREAK | CASE | CATCH | CONTINUE | DEFAULT | DELETE | DO | ELSE | FINALLY | FOR | FUNCTION | IF | IN | INSTANCEOF | NEW | RETURN | SWITCH | THIS | THROW | TRY | TYPEOF | VAR | VOID | WHILE | WITH )
			DebugEnterAlt(1);
			// EcmaScript.g:
			{
			DebugLocation(345, 2);
			if (input.LA(1)==BREAK||(input.LA(1)>=CASE && input.LA(1)<=CATCH)||input.LA(1)==CONTINUE||(input.LA(1)>=DEFAULT && input.LA(1)<=DELETE)||input.LA(1)==DO||input.LA(1)==ELSE||input.LA(1)==FINALLY||input.LA(1)==FOR||input.LA(1)==FUNCTION||input.LA(1)==IF||input.LA(1)==IN||input.LA(1)==INSTANCEOF||input.LA(1)==NEW||input.LA(1)==RETURN||input.LA(1)==SWITCH||(input.LA(1)>=THIS && input.LA(1)<=THROW)||(input.LA(1)>=TRY && input.LA(1)<=TYPEOF)||(input.LA(1)>=VAR && input.LA(1)<=VOID)||(input.LA(1)>=WHILE && input.LA(1)<=WITH))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("keyword", 3);
			LeaveRule("keyword", 3);
			LeaveRule_keyword();
		}
		DebugLocation(370, 1);
		} finally { DebugExitRule(GrammarFileName, "keyword"); }
		return;

	}
	// $ANTLR end "keyword"


	partial void EnterRule_futureReservedWord();
	partial void LeaveRule_futureReservedWord();

	// $ANTLR start "futureReservedWord"
	// EcmaScript.g:376:1: futureReservedWord : ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DEBUGGER | DOUBLE | ENUM | EXPORT | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE );
	[GrammarRule("futureReservedWord")]
	private void futureReservedWord()
	{
		EnterRule_futureReservedWord();
		EnterRule("futureReservedWord", 4);
		TraceIn("futureReservedWord", 4);
		try { DebugEnterRule(GrammarFileName, "futureReservedWord");
		DebugLocation(376, 1);
		try
		{
			// EcmaScript.g:377:2: ( ABSTRACT | BOOLEAN | BYTE | CHAR | CLASS | CONST | DEBUGGER | DOUBLE | ENUM | EXPORT | EXTENDS | FINAL | FLOAT | GOTO | IMPLEMENTS | IMPORT | INT | INTERFACE | LONG | NATIVE | PACKAGE | PRIVATE | PROTECTED | PUBLIC | SHORT | STATIC | SUPER | SYNCHRONIZED | THROWS | TRANSIENT | VOLATILE )
			DebugEnterAlt(1);
			// EcmaScript.g:
			{
			DebugLocation(377, 2);
			if (input.LA(1)==ABSTRACT||input.LA(1)==BOOLEAN||input.LA(1)==BYTE||(input.LA(1)>=CHAR && input.LA(1)<=CLASS)||input.LA(1)==CONST||input.LA(1)==DEBUGGER||input.LA(1)==DOUBLE||input.LA(1)==ENUM||input.LA(1)==EXPORT||input.LA(1)==EXTENDS||input.LA(1)==FINAL||input.LA(1)==FLOAT||input.LA(1)==GOTO||(input.LA(1)>=IMPLEMENTS && input.LA(1)<=IMPORT)||(input.LA(1)>=INT && input.LA(1)<=INTERFACE)||input.LA(1)==LONG||input.LA(1)==NATIVE||input.LA(1)==PACKAGE||(input.LA(1)>=PRIVATE && input.LA(1)<=PROTECTED)||input.LA(1)==PUBLIC||input.LA(1)==SHORT||input.LA(1)==STATIC||input.LA(1)==SUPER||input.LA(1)==SYNCHRONIZED||(input.LA(1)>=THROWS && input.LA(1)<=TRANSIENT)||input.LA(1)==VOLATILE)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("futureReservedWord", 4);
			LeaveRule("futureReservedWord", 4);
			LeaveRule_futureReservedWord();
		}
		DebugLocation(408, 1);
		} finally { DebugExitRule(GrammarFileName, "futureReservedWord"); }
		return;

	}
	// $ANTLR end "futureReservedWord"


	partial void EnterRule_punctuator();
	partial void LeaveRule_punctuator();

	// $ANTLR start "punctuator"
	// EcmaScript.g:462:1: punctuator : ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS );
	[GrammarRule("punctuator")]
	private void punctuator()
	{
		EnterRule_punctuator();
		EnterRule("punctuator", 5);
		TraceIn("punctuator", 5);
		try { DebugEnterRule(GrammarFileName, "punctuator");
		DebugLocation(462, 1);
		try
		{
			// EcmaScript.g:463:2: ( LBRACE | RBRACE | LPAREN | RPAREN | LBRACK | RBRACK | DOT | SEMIC | COMMA | LT | GT | LTE | GTE | EQ | NEQ | SAME | NSAME | ADD | SUB | MUL | MOD | INC | DEC | SHL | SHR | SHU | AND | OR | XOR | NOT | INV | LAND | LOR | QUE | COLON | ASSIGN | ADDASS | SUBASS | MULASS | MODASS | SHLASS | SHRASS | SHUASS | ANDASS | ORASS | XORASS | DIV | DIVASS )
			DebugEnterAlt(1);
			// EcmaScript.g:
			{
			DebugLocation(463, 2);
			if ((input.LA(1)>=ADD && input.LA(1)<=ANDASS)||input.LA(1)==ASSIGN||(input.LA(1)>=COLON && input.LA(1)<=COMMA)||input.LA(1)==DEC||(input.LA(1)>=DIV && input.LA(1)<=DIVASS)||input.LA(1)==DOT||input.LA(1)==EQ||(input.LA(1)>=GT && input.LA(1)<=GTE)||input.LA(1)==INC||input.LA(1)==INV||(input.LA(1)>=LAND && input.LA(1)<=LBRACK)||(input.LA(1)>=LOR && input.LA(1)<=LPAREN)||(input.LA(1)>=LT && input.LA(1)<=LTE)||(input.LA(1)>=MOD && input.LA(1)<=MULASS)||input.LA(1)==NEQ||(input.LA(1)>=NOT && input.LA(1)<=NSAME)||(input.LA(1)>=OR && input.LA(1)<=ORASS)||(input.LA(1)>=QUE && input.LA(1)<=RBRACK)||input.LA(1)==RPAREN||(input.LA(1)>=SAME && input.LA(1)<=SHLASS)||(input.LA(1)>=SHR && input.LA(1)<=SHUASS)||(input.LA(1)>=SUB && input.LA(1)<=SUBASS)||(input.LA(1)>=XOR && input.LA(1)<=XORASS))
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("punctuator", 5);
			LeaveRule("punctuator", 5);
			LeaveRule_punctuator();
		}
		DebugLocation(511, 1);
		} finally { DebugExitRule(GrammarFileName, "punctuator"); }
		return;

	}
	// $ANTLR end "punctuator"


	partial void EnterRule_literal();
	partial void LeaveRule_literal();

	// $ANTLR start "literal"
	// EcmaScript.g:517:1: literal returns [ExpressionSyntax value] : (exp1= NULL |exp2= booleanLiteral |exp3= numericLiteral |exp4= StringLiteral |exp5= RegularExpressionLiteral );
	[GrammarRule("literal")]
	private ExpressionSyntax literal()
	{
		EnterRule_literal();
		EnterRule("literal", 6);
		TraceIn("literal", 6);
		ExpressionSyntax value = default(ExpressionSyntax);

		IToken exp1 = default(IToken);
		IToken exp4 = default(IToken);
		IToken exp5 = default(IToken);
		bool exp2 = default(bool);
		double exp3 = default(double);

		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(517, 1);
		try
		{
			// EcmaScript.g:518:2: (exp1= NULL |exp2= booleanLiteral |exp3= numericLiteral |exp4= StringLiteral |exp5= RegularExpressionLiteral )
			int alt3=5;
			try { DebugEnterDecision(3, false);
			switch (input.LA(1))
			{
			case NULL:
				{
				alt3 = 1;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt3 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt3 = 3;
				}
				break;
			case StringLiteral:
				{
				alt3 = 4;
				}
				break;
			case RegularExpressionLiteral:
				{
				alt3 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:518:4: exp1= NULL
				{
				DebugLocation(518, 8);
				exp1=(IToken)Match(input,NULL,Follow._NULL_in_literal2532); 
				DebugLocation(518, 14);
				 value = _builder.BuildIdentifier(exp1.Text); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:519:4: exp2= booleanLiteral
				{
				DebugLocation(519, 8);
				PushFollow(Follow._booleanLiteral_in_literal2541);
				exp2=booleanLiteral();
				PopFollow();

				DebugLocation(519, 24);
				 value = _builder.BuildConstant(exp2); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:520:4: exp3= numericLiteral
				{
				DebugLocation(520, 8);
				PushFollow(Follow._numericLiteral_in_literal2550);
				exp3=numericLiteral();
				PopFollow();

				DebugLocation(520, 24);
				 value = _builder.BuildConstant(exp3); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:521:4: exp4= StringLiteral
				{
				DebugLocation(521, 8);
				exp4=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_literal2559); 
				DebugLocation(521, 24);
				 value = _builder.BuildConstant(ExtractString(exp4.Text)); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// EcmaScript.g:522:4: exp5= RegularExpressionLiteral
				{
				DebugLocation(522, 8);
				exp5=(IToken)Match(input,RegularExpressionLiteral,Follow._RegularExpressionLiteral_in_literal2569); 
				DebugLocation(522, 34);
				 value = _builder.BuildRegularExpression(ExtractRegExpPattern(exp5.Text), ExtractRegExpOption(exp5.Text)); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("literal", 6);
			LeaveRule("literal", 6);
			LeaveRule_literal();
		}
		DebugLocation(523, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return value;

	}
	// $ANTLR end "literal"


	partial void EnterRule_booleanLiteral();
	partial void LeaveRule_booleanLiteral();

	// $ANTLR start "booleanLiteral"
	// EcmaScript.g:525:1: booleanLiteral returns [bool value] : ( TRUE | FALSE );
	[GrammarRule("booleanLiteral")]
	private bool booleanLiteral()
	{
		EnterRule_booleanLiteral();
		EnterRule("booleanLiteral", 7);
		TraceIn("booleanLiteral", 7);
		bool value = default(bool);

		try { DebugEnterRule(GrammarFileName, "booleanLiteral");
		DebugLocation(525, 1);
		try
		{
			// EcmaScript.g:526:2: ( TRUE | FALSE )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==TRUE))
			{
				alt4 = 1;
			}
			else if ((LA4_0==FALSE))
			{
				alt4 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:526:4: TRUE
				{
				DebugLocation(526, 4);
				Match(input,TRUE,Follow._TRUE_in_booleanLiteral2586); 
				DebugLocation(526, 9);
				 value = true; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:527:4: FALSE
				{
				DebugLocation(527, 4);
				Match(input,FALSE,Follow._FALSE_in_booleanLiteral2593); 
				DebugLocation(527, 10);
				 value = false; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("booleanLiteral", 7);
			LeaveRule("booleanLiteral", 7);
			LeaveRule_booleanLiteral();
		}
		DebugLocation(528, 1);
		} finally { DebugExitRule(GrammarFileName, "booleanLiteral"); }
		return value;

	}
	// $ANTLR end "booleanLiteral"


	partial void EnterRule_numericLiteral();
	partial void LeaveRule_numericLiteral();

	// $ANTLR start "numericLiteral"
	// EcmaScript.g:572:1: numericLiteral returns [double value] : (ex1= DecimalLiteral |ex2= OctalIntegerLiteral |ex3= HexIntegerLiteral );
	[GrammarRule("numericLiteral")]
	private double numericLiteral()
	{
		EnterRule_numericLiteral();
		EnterRule("numericLiteral", 8);
		TraceIn("numericLiteral", 8);
		double value = default(double);

		IToken ex1 = default(IToken);
		IToken ex2 = default(IToken);
		IToken ex3 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "numericLiteral");
		DebugLocation(572, 1);
		try
		{
			// EcmaScript.g:573:2: (ex1= DecimalLiteral |ex2= OctalIntegerLiteral |ex3= HexIntegerLiteral )
			int alt5=3;
			try { DebugEnterDecision(5, false);
			switch (input.LA(1))
			{
			case DecimalLiteral:
				{
				alt5 = 1;
				}
				break;
			case OctalIntegerLiteral:
				{
				alt5 = 2;
				}
				break;
			case HexIntegerLiteral:
				{
				alt5 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:573:4: ex1= DecimalLiteral
				{
				DebugLocation(573, 7);
				ex1=(IToken)Match(input,DecimalLiteral,Follow._DecimalLiteral_in_numericLiteral2804); 
				DebugLocation(573, 23);
				 value = double.Parse(ex1.Text, NumberStyles.Float, _numberFormatInfo); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:574:4: ex2= OctalIntegerLiteral
				{
				DebugLocation(574, 7);
				ex2=(IToken)Match(input,OctalIntegerLiteral,Follow._OctalIntegerLiteral_in_numericLiteral2813); 
				DebugLocation(574, 28);
				 value = System.Convert.ToInt64(ex2.Text, 8); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:575:4: ex3= HexIntegerLiteral
				{
				DebugLocation(575, 7);
				ex3=(IToken)Match(input,HexIntegerLiteral,Follow._HexIntegerLiteral_in_numericLiteral2822); 
				DebugLocation(575, 26);
				 value = System.Convert.ToInt64(ex3.Text, 16); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("numericLiteral", 8);
			LeaveRule("numericLiteral", 8);
			LeaveRule_numericLiteral();
		}
		DebugLocation(576, 1);
		} finally { DebugExitRule(GrammarFileName, "numericLiteral"); }
		return value;

	}
	// $ANTLR end "numericLiteral"


	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();

	// $ANTLR start "primaryExpression"
	// EcmaScript.g:662:1: primaryExpression returns [ExpressionSyntax value] : (ex1= THIS |ex2= Identifier |ex3= literal |ex4= arrayLiteral |ex5= objectLiteral |lpar= LPAREN ex6= expression RPAREN );
	[GrammarRule("primaryExpression")]
	private ExpressionSyntax primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 9);
		TraceIn("primaryExpression", 9);
		ExpressionSyntax value = default(ExpressionSyntax);

		IToken ex1 = default(IToken);
		IToken ex2 = default(IToken);
		IToken lpar = default(IToken);
		ExpressionSyntax ex3 = default(ExpressionSyntax);
		ArrayDeclarationSyntax ex4 = default(ArrayDeclarationSyntax);
		JsonExpressionSyntax ex5 = default(JsonExpressionSyntax);
		ExpressionSyntax ex6 = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(662, 1);
		try
		{
			// EcmaScript.g:663:2: (ex1= THIS |ex2= Identifier |ex3= literal |ex4= arrayLiteral |ex5= objectLiteral |lpar= LPAREN ex6= expression RPAREN )
			int alt6=6;
			try { DebugEnterDecision(6, false);
			switch (input.LA(1))
			{
			case THIS:
				{
				alt6 = 1;
				}
				break;
			case Identifier:
				{
				alt6 = 2;
				}
				break;
			case DecimalLiteral:
			case FALSE:
			case HexIntegerLiteral:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case StringLiteral:
			case TRUE:
				{
				alt6 = 3;
				}
				break;
			case LBRACK:
				{
				alt6 = 4;
				}
				break;
			case LBRACE:
				{
				alt6 = 5;
				}
				break;
			case LPAREN:
				{
				alt6 = 6;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:663:4: ex1= THIS
				{
				DebugLocation(663, 7);
				ex1=(IToken)Match(input,THIS,Follow._THIS_in_primaryExpression3236); 
				DebugLocation(663, 13);
				 value = _builder.BuildIdentifier(ex1.Text); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:664:4: ex2= Identifier
				{
				DebugLocation(664, 7);
				ex2=(IToken)Match(input,Identifier,Follow._Identifier_in_primaryExpression3245); 
				DebugLocation(664, 19);
				 value = _builder.BuildIdentifier(ex2.Text); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:665:4: ex3= literal
				{
				DebugLocation(665, 7);
				PushFollow(Follow._literal_in_primaryExpression3254);
				ex3=literal();
				PopFollow();

				DebugLocation(665, 16);
				 value = ex3; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:666:4: ex4= arrayLiteral
				{
				DebugLocation(666, 7);
				PushFollow(Follow._arrayLiteral_in_primaryExpression3263);
				ex4=arrayLiteral();
				PopFollow();

				DebugLocation(666, 21);
				 value = ex4; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// EcmaScript.g:667:4: ex5= objectLiteral
				{
				DebugLocation(667, 7);
				PushFollow(Follow._objectLiteral_in_primaryExpression3272);
				ex5=objectLiteral();
				PopFollow();

				DebugLocation(667, 22);
				 value = ex5; 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// EcmaScript.g:668:4: lpar= LPAREN ex6= expression RPAREN
				{
				DebugLocation(668, 8);
				lpar=(IToken)Match(input,LPAREN,Follow._LPAREN_in_primaryExpression3281); 
				DebugLocation(668, 19);
				PushFollow(Follow._expression_in_primaryExpression3285);
				ex6=expression();
				PopFollow();

				DebugLocation(668, 32);
				Match(input,RPAREN,Follow._RPAREN_in_primaryExpression3288); 
				DebugLocation(668, 40);
				 value = ex6; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("primaryExpression", 9);
			LeaveRule("primaryExpression", 9);
			LeaveRule_primaryExpression();
		}
		DebugLocation(669, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return value;

	}
	// $ANTLR end "primaryExpression"


	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();

	// $ANTLR start "arrayLiteral"
	// EcmaScript.g:671:1: arrayLiteral returns [ArrayDeclarationSyntax value] : lb= LBRACK (first= arrayItem ( COMMA follow= arrayItem )* )? RBRACK ;
	[GrammarRule("arrayLiteral")]
	private ArrayDeclarationSyntax arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 10);
		TraceIn("arrayLiteral", 10);
		ArrayDeclarationSyntax value = default(ArrayDeclarationSyntax);

		IToken lb = default(IToken);
		SyntaxNode first = default(SyntaxNode);
		SyntaxNode follow = default(SyntaxNode);


		    var parameters = new ReadOnlyArray<SyntaxNode>.Builder();

		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(671, 1);
		try
		{
			// EcmaScript.g:678:2: (lb= LBRACK (first= arrayItem ( COMMA follow= arrayItem )* )? RBRACK )
			DebugEnterAlt(1);
			// EcmaScript.g:679:9: lb= LBRACK (first= arrayItem ( COMMA follow= arrayItem )* )? RBRACK
			{
			DebugLocation(679, 11);
			lb=(IToken)Match(input,LBRACK,Follow._LBRACK_in_arrayLiteral3327); 
			DebugLocation(680, 3);
			// EcmaScript.g:680:3: (first= arrayItem ( COMMA follow= arrayItem )* )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==ADD||LA8_0==COMMA||LA8_0==DEC||LA8_0==DELETE||LA8_0==DecimalLiteral||LA8_0==FALSE||LA8_0==FUNCTION||LA8_0==HexIntegerLiteral||LA8_0==INC||LA8_0==INV||LA8_0==Identifier||(LA8_0>=LBRACE && LA8_0<=LBRACK)||LA8_0==LPAREN||(LA8_0>=NEW && LA8_0<=NOT)||LA8_0==NULL||LA8_0==OctalIntegerLiteral||LA8_0==RegularExpressionLiteral||LA8_0==SUB||LA8_0==StringLiteral||LA8_0==THIS||LA8_0==TRUE||LA8_0==TYPEOF||LA8_0==VOID))
			{
				alt8 = 1;
			}
			else if ((LA8_0==RBRACK))
			{
				int LA8_2 = input.LA(2);

				if (((( input.LA(1) == COMMA )||( input.LA(1) == RBRACK ))))
				{
					alt8 = 1;
				}
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:681:13: first= arrayItem ( COMMA follow= arrayItem )*
				{
				DebugLocation(681, 18);
				PushFollow(Follow._arrayItem_in_arrayLiteral3347);
				first=arrayItem();
				PopFollow();

				DebugLocation(682, 13);
				 if(first != null) parameters.Add(first); 
				DebugLocation(683, 13);
				// EcmaScript.g:683:13: ( COMMA follow= arrayItem )*
				try { DebugEnterSubRule(7);
				while (true)
				{
					int alt7=2;
					try { DebugEnterDecision(7, false);
					int LA7_0 = input.LA(1);

					if ((LA7_0==COMMA))
					{
						alt7 = 1;
					}


					} finally { DebugExitDecision(7); }
					switch ( alt7 )
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:684:17: COMMA follow= arrayItem
						{
						DebugLocation(684, 17);
						Match(input,COMMA,Follow._COMMA_in_arrayLiteral3393); 
						DebugLocation(684, 29);
						PushFollow(Follow._arrayItem_in_arrayLiteral3397);
						follow=arrayItem();
						PopFollow();

						DebugLocation(685, 17);
						 if(follow != null) parameters.Add(follow); 

						}
						break;

					default:
						goto loop7;
					}
				}

				loop7:
					;

				} finally { DebugExitSubRule(7); }


				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(688, 9);
			Match(input,RBRACK,Follow._RBRACK_in_arrayLiteral3451); 

			}


				value = _builder.BuildArrayDeclaration(parameters.ToReadOnly());

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arrayLiteral", 10);
			LeaveRule("arrayLiteral", 10);
			LeaveRule_arrayLiteral();
		}
		DebugLocation(689, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return value;

	}
	// $ANTLR end "arrayLiteral"


	partial void EnterRule_arrayItem();
	partial void LeaveRule_arrayItem();

	// $ANTLR start "arrayItem"
	// EcmaScript.g:691:1: arrayItem returns [SyntaxNode value] : (expr= assignmentExpression |{...}?|{...}?) ;
	[GrammarRule("arrayItem")]
	private SyntaxNode arrayItem()
	{
		EnterRule_arrayItem();
		EnterRule("arrayItem", 11);
		TraceIn("arrayItem", 11);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax expr = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "arrayItem");
		DebugLocation(691, 1);
		try
		{
			// EcmaScript.g:692:2: ( (expr= assignmentExpression |{...}?|{...}?) )
			DebugEnterAlt(1);
			// EcmaScript.g:693:3: (expr= assignmentExpression |{...}?|{...}?)
			{
			DebugLocation(693, 3);
			// EcmaScript.g:693:3: (expr= assignmentExpression |{...}?|{...}?)
			int alt9=3;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			switch (input.LA(1))
			{
			case ADD:
			case DEC:
			case DELETE:
			case DecimalLiteral:
			case FALSE:
			case FUNCTION:
			case HexIntegerLiteral:
			case INC:
			case INV:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NEW:
			case NOT:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case SUB:
			case StringLiteral:
			case THIS:
			case TRUE:
			case TYPEOF:
			case VOID:
				{
				alt9 = 1;
				}
				break;
			case COMMA:
				{
				int LA9_2 = input.LA(2);

				if ((( input.LA(1) == COMMA )))
				{
					alt9 = 2;
				}
				else if ((( input.LA(1) == RBRACK )))
				{
					alt9 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case RBRACK:
				{
				int LA9_3 = input.LA(2);

				if ((( input.LA(1) == COMMA )))
				{
					alt9 = 2;
				}
				else if ((( input.LA(1) == RBRACK )))
				{
					alt9 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:694:4: expr= assignmentExpression
				{
				DebugLocation(694, 8);
				PushFollow(Follow._assignmentExpression_in_arrayItem3475);
				expr=assignmentExpression();
				PopFollow();

				DebugLocation(695, 4);
				 value = expr; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:697:4: {...}?
				{
				DebugLocation(697, 4);
				if (!(( input.LA(1) == COMMA )))
				{
					throw new FailedPredicateException(input, "arrayItem", " input.LA(1) == COMMA ");
				}
				DebugLocation(698, 4);
				 value = _builder.BuildIdentifier("undefined"); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:700:4: {...}?
				{
				DebugLocation(700, 4);
				if (!(( input.LA(1) == RBRACK )))
				{
					throw new FailedPredicateException(input, "arrayItem", " input.LA(1) == RBRACK ");
				}
				DebugLocation(701, 4);
				 value = null; 

				}
				break;

			}
			} finally { DebugExitSubRule(9); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arrayItem", 11);
			LeaveRule("arrayItem", 11);
			LeaveRule_arrayItem();
		}
		DebugLocation(703, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayItem"); }
		return value;

	}
	// $ANTLR end "arrayItem"


	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();

	// $ANTLR start "objectLiteral"
	// EcmaScript.g:705:1: objectLiteral returns [JsonExpressionSyntax value] : lb= LBRACE (first= propertyAssignment ( COMMA follow= propertyAssignment )* )? RBRACE ;
	[GrammarRule("objectLiteral")]
	private JsonExpressionSyntax objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 12);
		TraceIn("objectLiteral", 12);
		JsonExpressionSyntax value = default(JsonExpressionSyntax);

		IToken lb = default(IToken);
		PropertyDeclaration first = default(PropertyDeclaration);
		PropertyDeclaration follow = default(PropertyDeclaration);


		    var builder = new JsonPropertyBuilder();

		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(705, 1);
		try
		{
			// EcmaScript.g:712:2: (lb= LBRACE (first= propertyAssignment ( COMMA follow= propertyAssignment )* )? RBRACE )
			DebugEnterAlt(1);
			// EcmaScript.g:713:7: lb= LBRACE (first= propertyAssignment ( COMMA follow= propertyAssignment )* )? RBRACE
			{
			DebugLocation(713, 9);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_objectLiteral3546); 
			DebugLocation(713, 17);
			// EcmaScript.g:713:17: (first= propertyAssignment ( COMMA follow= propertyAssignment )* )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==DecimalLiteral||LA11_0==HexIntegerLiteral||LA11_0==Identifier||LA11_0==OctalIntegerLiteral||LA11_0==StringLiteral))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:714:9: first= propertyAssignment ( COMMA follow= propertyAssignment )*
				{
				DebugLocation(714, 14);
				PushFollow(Follow._propertyAssignment_in_objectLiteral3560);
				first=propertyAssignment();
				PopFollow();

				DebugLocation(714, 34);
				 builder.AddProperty(first); 
				DebugLocation(714, 66);
				// EcmaScript.g:714:66: ( COMMA follow= propertyAssignment )*
				try { DebugEnterSubRule(10);
				while (true)
				{
					int alt10=2;
					try { DebugEnterDecision(10, false);
					int LA10_0 = input.LA(1);

					if ((LA10_0==COMMA))
					{
						alt10 = 1;
					}


					} finally { DebugExitDecision(10); }
					switch ( alt10 )
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:715:11: COMMA follow= propertyAssignment
						{
						DebugLocation(715, 11);
						Match(input,COMMA,Follow._COMMA_in_objectLiteral3576); 
						DebugLocation(716, 17);
						PushFollow(Follow._propertyAssignment_in_objectLiteral3590);
						follow=propertyAssignment();
						PopFollow();

						DebugLocation(716, 37);
						 builder.AddProperty(follow); 

						}
						break;

					default:
						goto loop10;
					}
				}

				loop10:
					;

				} finally { DebugExitSubRule(10); }


				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(719, 7);
			Match(input,RBRACE,Follow._RBRACE_in_objectLiteral3620); 

			}


				value = _builder.BuildJsonExpression(builder.GetProperties());

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("objectLiteral", 12);
			LeaveRule("objectLiteral", 12);
			LeaveRule_objectLiteral();
		}
		DebugLocation(720, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return value;

	}
	// $ANTLR end "objectLiteral"


	partial void EnterRule_propertyAssignment();
	partial void LeaveRule_propertyAssignment();

	// $ANTLR start "propertyAssignment"
	// EcmaScript.g:722:1: propertyAssignment returns [PropertyDeclaration value] : (func= propertyFunctionAssignment |data= propertyValueAssignment );
	[GrammarRule("propertyAssignment")]
	private PropertyDeclaration propertyAssignment()
	{
		EnterRule_propertyAssignment();
		EnterRule("propertyAssignment", 13);
		TraceIn("propertyAssignment", 13);
		PropertyDeclaration value = default(PropertyDeclaration);

		PropertyDeclaration func = default(PropertyDeclaration);
		PropertyDeclaration data = default(PropertyDeclaration);

		try { DebugEnterRule(GrammarFileName, "propertyAssignment");
		DebugLocation(722, 1);
		try
		{
			// EcmaScript.g:723:2: (func= propertyFunctionAssignment |data= propertyValueAssignment )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==Identifier))
			{
				int LA12_1 = input.LA(2);

				if ((LA12_1==DecimalLiteral||LA12_1==HexIntegerLiteral||LA12_1==Identifier||LA12_1==OctalIntegerLiteral||LA12_1==StringLiteral))
				{
					alt12 = 1;
				}
				else if ((LA12_1==COLON))
				{
					alt12 = 2;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 12, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA12_0==DecimalLiteral||LA12_0==HexIntegerLiteral||LA12_0==OctalIntegerLiteral||LA12_0==StringLiteral))
			{
				alt12 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 12, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:724:9: func= propertyFunctionAssignment
				{
				DebugLocation(724, 13);
				PushFollow(Follow._propertyFunctionAssignment_in_propertyAssignment3646);
				func=propertyFunctionAssignment();
				PopFollow();

				DebugLocation(725, 9);
				 value = func; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:727:9: data= propertyValueAssignment
				{
				DebugLocation(727, 13);
				PushFollow(Follow._propertyValueAssignment_in_propertyAssignment3671);
				data=propertyValueAssignment();
				PopFollow();

				DebugLocation(728, 9);
				 value = data; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertyAssignment", 13);
			LeaveRule("propertyAssignment", 13);
			LeaveRule_propertyAssignment();
		}
		DebugLocation(729, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyAssignment"); }
		return value;

	}
	// $ANTLR end "propertyAssignment"


	partial void EnterRule_propertyFunctionAssignment();
	partial void LeaveRule_propertyFunctionAssignment();

	// $ANTLR start "propertyFunctionAssignment"
	// EcmaScript.g:731:1: propertyFunctionAssignment returns [PropertyDeclaration value] : acc= accessor prop2= propertyName (parms= formalParameterList )? functionBody ;
	[GrammarRule("propertyFunctionAssignment")]
	private PropertyDeclaration propertyFunctionAssignment()
	{
		EnterRule_propertyFunctionAssignment();
		EnterRule("propertyFunctionAssignment", 14);
		TraceIn("propertyFunctionAssignment", 14);
		PropertyDeclaration value = default(PropertyDeclaration);

		PropertyExpressionType acc = default(PropertyExpressionType);
		string prop2 = default(string);
		ReadOnlyArray<string> parms = default(ReadOnlyArray<string>);


		    PropertyExpressionType mode;
		    BodySyntax body;
		    var parameters = ReadOnlyArray<string>.Null;
		    string name;
		    IToken start = null;

		try { DebugEnterRule(GrammarFileName, "propertyFunctionAssignment");
		DebugLocation(731, 4);
		try
		{
			// EcmaScript.g:751:5: (acc= accessor prop2= propertyName (parms= formalParameterList )? functionBody )
			DebugEnterAlt(1);
			// EcmaScript.g:752:9: acc= accessor prop2= propertyName (parms= formalParameterList )? functionBody
			{
			DebugLocation(752, 12);
			PushFollow(Follow._accessor_in_propertyFunctionAssignment3719);
			acc=accessor();
			PopFollow();

			DebugLocation(753, 9);
			 mode = acc; 
			DebugLocation(754, 14);
			PushFollow(Follow._propertyName_in_propertyFunctionAssignment3741);
			prop2=propertyName();
			PopFollow();

			DebugLocation(755, 9);
			 name = prop2; 
			DebugLocation(756, 9);
			// EcmaScript.g:756:9: (parms= formalParameterList )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==LPAREN))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:757:13: parms= formalParameterList
				{
				DebugLocation(757, 13);
				 start = input.LT(1); 
				DebugLocation(758, 18);
				PushFollow(Follow._formalParameterList_in_propertyFunctionAssignment3791);
				parms=formalParameterList();
				PopFollow();

				DebugLocation(759, 13);
				 parameters = parms; 

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(761, 9);

			            if (start == null)
			                start = input.LT(1);
						_builder.EnterFunctionBody(parameters);
			        
			DebugLocation(766, 9);
			PushFollow(Follow._functionBody_in_propertyFunctionAssignment3836);
			functionBody();
			PopFollow();

			DebugLocation(767, 9);
			 body = _builder.ExitBody(); 

			}


			    value = new PropertyDeclaration(
			        name,
					_builder.BuildFunction(
			            name,
			            parameters,
			            body,
			            GetLocation(start, input.LT(-1))
			        ),
			        mode
			    );

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertyFunctionAssignment", 14);
			LeaveRule("propertyFunctionAssignment", 14);
			LeaveRule_propertyFunctionAssignment();
		}
		DebugLocation(768, 4);
		} finally { DebugExitRule(GrammarFileName, "propertyFunctionAssignment"); }
		return value;

	}
	// $ANTLR end "propertyFunctionAssignment"


	partial void EnterRule_propertyValueAssignment();
	partial void LeaveRule_propertyValueAssignment();

	// $ANTLR start "propertyValueAssignment"
	// EcmaScript.g:770:1: propertyValueAssignment returns [PropertyDeclaration value] : prop1= propertyName COLON ass= assignmentExpression ;
	[GrammarRule("propertyValueAssignment")]
	private PropertyDeclaration propertyValueAssignment()
	{
		EnterRule_propertyValueAssignment();
		EnterRule("propertyValueAssignment", 15);
		TraceIn("propertyValueAssignment", 15);
		PropertyDeclaration value = default(PropertyDeclaration);

		string prop1 = default(string);
		ExpressionSyntax ass = default(ExpressionSyntax);


		    string name;
		    ExpressionSyntax expression;

		try { DebugEnterRule(GrammarFileName, "propertyValueAssignment");
		DebugLocation(770, 4);
		try
		{
			// EcmaScript.g:782:5: (prop1= propertyName COLON ass= assignmentExpression )
			DebugEnterAlt(1);
			// EcmaScript.g:783:9: prop1= propertyName COLON ass= assignmentExpression
			{
			DebugLocation(783, 14);
			PushFollow(Follow._propertyName_in_propertyValueAssignment3888);
			prop1=propertyName();
			PopFollow();

			DebugLocation(784, 9);
			 name = prop1; 
			DebugLocation(785, 9);
			Match(input,COLON,Follow._COLON_in_propertyValueAssignment3908); 
			DebugLocation(786, 12);
			PushFollow(Follow._assignmentExpression_in_propertyValueAssignment3920);
			ass=assignmentExpression();
			PopFollow();

			DebugLocation(787, 9);
			 expression = ass; 

			}


			    value = new PropertyDeclaration(
			        name,
			        expression,
			        PropertyExpressionType.Data
			    );

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertyValueAssignment", 15);
			LeaveRule("propertyValueAssignment", 15);
			LeaveRule_propertyValueAssignment();
		}
		DebugLocation(788, 4);
		} finally { DebugExitRule(GrammarFileName, "propertyValueAssignment"); }
		return value;

	}
	// $ANTLR end "propertyValueAssignment"


	partial void EnterRule_accessor();
	partial void LeaveRule_accessor();

	// $ANTLR start "accessor"
	// EcmaScript.g:790:1: accessor returns [PropertyExpressionType value] : ex1= Identifier {...}? =>;
	[GrammarRule("accessor")]
	private PropertyExpressionType accessor()
	{
		EnterRule_accessor();
		EnterRule("accessor", 16);
		TraceIn("accessor", 16);
		PropertyExpressionType value = default(PropertyExpressionType);

		IToken ex1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "accessor");
		DebugLocation(790, 1);
		try
		{
			// EcmaScript.g:791:2: (ex1= Identifier {...}? =>)
			DebugEnterAlt(1);
			// EcmaScript.g:792:3: ex1= Identifier {...}? =>
			{
			DebugLocation(792, 6);
			ex1=(IToken)Match(input,Identifier,Follow._Identifier_in_accessor3960); 
			DebugLocation(793, 3);
			if (!(( ex1.Text=="get" || ex1.Text=="set" )))
			{
				throw new FailedPredicateException(input, "accessor", " ex1.Text==\"get\" || ex1.Text==\"set\" ");
			}
			DebugLocation(794, 3);

						if (ex1.Text == "get")
							value = PropertyExpressionType.Get;
						if (ex1.Text == "set")
							value = PropertyExpressionType.Set;
					

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("accessor", 16);
			LeaveRule("accessor", 16);
			LeaveRule_accessor();
		}
		DebugLocation(800, 1);
		} finally { DebugExitRule(GrammarFileName, "accessor"); }
		return value;

	}
	// $ANTLR end "accessor"


	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();

	// $ANTLR start "propertyName"
	// EcmaScript.g:802:1: propertyName returns [string value] : (ex1= Identifier |ex2= StringLiteral |ex3= numericLiteral );
	[GrammarRule("propertyName")]
	private string propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 17);
		TraceIn("propertyName", 17);
		string value = default(string);

		IToken ex1 = default(IToken);
		IToken ex2 = default(IToken);
		double ex3 = default(double);

		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(802, 1);
		try
		{
			// EcmaScript.g:803:2: (ex1= Identifier |ex2= StringLiteral |ex3= numericLiteral )
			int alt14=3;
			try { DebugEnterDecision(14, false);
			switch (input.LA(1))
			{
			case Identifier:
				{
				alt14 = 1;
				}
				break;
			case StringLiteral:
				{
				alt14 = 2;
				}
				break;
			case DecimalLiteral:
			case HexIntegerLiteral:
			case OctalIntegerLiteral:
				{
				alt14 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:803:4: ex1= Identifier
				{
				DebugLocation(803, 7);
				ex1=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyName3986); 
				DebugLocation(803, 19);
				 value = ex1.Text; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:804:4: ex2= StringLiteral
				{
				DebugLocation(804, 7);
				ex2=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_propertyName3995); 
				DebugLocation(804, 22);
				 value = ExtractString(ex2.Text); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:805:4: ex3= numericLiteral
				{
				DebugLocation(805, 7);
				PushFollow(Follow._numericLiteral_in_propertyName4004);
				ex3=numericLiteral();
				PopFollow();

				DebugLocation(805, 23);
				 value = ex3.ToString(); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("propertyName", 17);
			LeaveRule("propertyName", 17);
			LeaveRule_propertyName();
		}
		DebugLocation(806, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return value;

	}
	// $ANTLR end "propertyName"


	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();

	// $ANTLR start "memberExpression"
	// EcmaScript.g:818:1: memberExpression returns [ExpressionSyntax value] : (prim= primaryExpression |func= functionExpression );
	[GrammarRule("memberExpression")]
	private ExpressionSyntax memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 18);
		TraceIn("memberExpression", 18);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax prim = default(ExpressionSyntax);
		FunctionSyntax func = default(FunctionSyntax);

		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(818, 1);
		try
		{
			// EcmaScript.g:819:2: (prim= primaryExpression |func= functionExpression )
			int alt15=2;
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==DecimalLiteral||LA15_0==FALSE||LA15_0==HexIntegerLiteral||LA15_0==Identifier||(LA15_0>=LBRACE && LA15_0<=LBRACK)||LA15_0==LPAREN||LA15_0==NULL||LA15_0==OctalIntegerLiteral||LA15_0==RegularExpressionLiteral||LA15_0==StringLiteral||LA15_0==THIS||LA15_0==TRUE))
			{
				alt15 = 1;
			}
			else if ((LA15_0==FUNCTION))
			{
				alt15 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:819:4: prim= primaryExpression
				{
				DebugLocation(819, 8);
				PushFollow(Follow._primaryExpression_in_memberExpression4030);
				prim=primaryExpression();
				PopFollow();

				DebugLocation(819, 27);
				 value = prim; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:820:4: func= functionExpression
				{
				DebugLocation(820, 8);
				PushFollow(Follow._functionExpression_in_memberExpression4039);
				func=functionExpression();
				PopFollow();

				DebugLocation(820, 28);
				 value = func; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("memberExpression", 18);
			LeaveRule("memberExpression", 18);
			LeaveRule_memberExpression();
		}
		DebugLocation(821, 1);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return value;

	}
	// $ANTLR end "memberExpression"


	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();

	// $ANTLR start "arguments"
	// EcmaScript.g:823:1: arguments returns [ReadOnlyArray<MethodArgument> value] : LPAREN (first= argument ( COMMA follow= argument )* )? RPAREN ;
	[GrammarRule("arguments")]
	private ReadOnlyArray<MethodArgument> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 19);
		TraceIn("arguments", 19);
		ReadOnlyArray<MethodArgument> value = default(ReadOnlyArray<MethodArgument>);

		MethodArgument first = default(MethodArgument);
		MethodArgument follow = default(MethodArgument);


			var arguments = new ReadOnlyArray<MethodArgument>.Builder();

		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(823, 1);
		try
		{
			// EcmaScript.g:830:2: ( LPAREN (first= argument ( COMMA follow= argument )* )? RPAREN )
			DebugEnterAlt(1);
			// EcmaScript.g:831:9: LPAREN (first= argument ( COMMA follow= argument )* )? RPAREN
			{
			DebugLocation(831, 9);
			Match(input,LPAREN,Follow._LPAREN_in_arguments4075); 
			DebugLocation(832, 9);
			// EcmaScript.g:832:9: (first= argument ( COMMA follow= argument )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_0 = input.LA(1);

			if ((LA17_0==ADD||LA17_0==DEC||LA17_0==DELETE||LA17_0==DecimalLiteral||LA17_0==FALSE||LA17_0==FUNCTION||LA17_0==HexIntegerLiteral||LA17_0==INC||LA17_0==INV||LA17_0==Identifier||(LA17_0>=LBRACE && LA17_0<=LBRACK)||LA17_0==LPAREN||(LA17_0>=NEW && LA17_0<=NOT)||LA17_0==NULL||LA17_0==OctalIntegerLiteral||LA17_0==REF||LA17_0==RegularExpressionLiteral||LA17_0==SUB||LA17_0==StringLiteral||LA17_0==THIS||LA17_0==TRUE||LA17_0==TYPEOF||LA17_0==VOID))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:833:13: first= argument ( COMMA follow= argument )*
				{
				DebugLocation(833, 18);
				PushFollow(Follow._argument_in_arguments4101);
				first=argument();
				PopFollow();

				DebugLocation(834, 13);
				 arguments.Add(first); 
				DebugLocation(835, 13);
				// EcmaScript.g:835:13: ( COMMA follow= argument )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_0 = input.LA(1);

					if ((LA16_0==COMMA))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:836:17: COMMA follow= argument
						{
						DebugLocation(836, 17);
						Match(input,COMMA,Follow._COMMA_in_arguments4147); 
						DebugLocation(837, 23);
						PushFollow(Follow._argument_in_arguments4167);
						follow=argument();
						PopFollow();

						DebugLocation(838, 17);
						 arguments.Add(follow); 

						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(841, 9);
			Match(input,RPAREN,Follow._RPAREN_in_arguments4221); 

			}


				value = arguments.ToReadOnly();

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("arguments", 19);
			LeaveRule("arguments", 19);
			LeaveRule_arguments();
		}
		DebugLocation(842, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return value;

	}
	// $ANTLR end "arguments"


	partial void EnterRule_argument();
	partial void LeaveRule_argument();

	// $ANTLR start "argument"
	// EcmaScript.g:844:1: argument returns [MethodArgument value] : ( REF )? ex= assignmentExpression ;
	[GrammarRule("argument")]
	private MethodArgument argument()
	{
		EnterRule_argument();
		EnterRule("argument", 20);
		TraceIn("argument", 20);
		MethodArgument value = default(MethodArgument);

		ExpressionSyntax ex = default(ExpressionSyntax);


		    bool isRef = false;

		try { DebugEnterRule(GrammarFileName, "argument");
		DebugLocation(844, 4);
		try
		{
			// EcmaScript.g:848:5: ( ( REF )? ex= assignmentExpression )
			DebugEnterAlt(1);
			// EcmaScript.g:849:9: ( REF )? ex= assignmentExpression
			{
			DebugLocation(849, 9);
			// EcmaScript.g:849:9: ( REF )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==REF))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:849:11: REF
				{
				DebugLocation(849, 11);
				Match(input,REF,Follow._REF_in_argument4254); 
				DebugLocation(849, 15);
				 isRef = true; 

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(850, 11);
			PushFollow(Follow._assignmentExpression_in_argument4271);
			ex=assignmentExpression();
			PopFollow();

			DebugLocation(851, 9);
			 value = _builder.BuildMethodArgument(ex, isRef); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("argument", 20);
			LeaveRule("argument", 20);
			LeaveRule_argument();
		}
		DebugLocation(852, 4);
		} finally { DebugExitRule(GrammarFileName, "argument"); }
		return value;

	}
	// $ANTLR end "argument"


	partial void EnterRule_generics();
	partial void LeaveRule_generics();

	// $ANTLR start "generics"
	// EcmaScript.g:854:1: generics returns [ReadOnlyArray<ExpressionSyntax> value] : LBRACE (first= assignmentExpression ( COMMA follow= assignmentExpression )* )? RBRACE ;
	[GrammarRule("generics")]
	private ReadOnlyArray<ExpressionSyntax> generics()
	{
		EnterRule_generics();
		EnterRule("generics", 21);
		TraceIn("generics", 21);
		ReadOnlyArray<ExpressionSyntax> value = default(ReadOnlyArray<ExpressionSyntax>);

		ExpressionSyntax first = default(ExpressionSyntax);
		ExpressionSyntax follow = default(ExpressionSyntax);


			var generics = new ReadOnlyArray<ExpressionSyntax>.Builder();

		try { DebugEnterRule(GrammarFileName, "generics");
		DebugLocation(854, 1);
		try
		{
			// EcmaScript.g:861:2: ( LBRACE (first= assignmentExpression ( COMMA follow= assignmentExpression )* )? RBRACE )
			DebugEnterAlt(1);
			// EcmaScript.g:862:3: LBRACE (first= assignmentExpression ( COMMA follow= assignmentExpression )* )? RBRACE
			{
			DebugLocation(862, 3);
			Match(input,LBRACE,Follow._LBRACE_in_generics4311); 
			DebugLocation(863, 3);
			// EcmaScript.g:863:3: (first= assignmentExpression ( COMMA follow= assignmentExpression )* )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0==ADD||LA20_0==DEC||LA20_0==DELETE||LA20_0==DecimalLiteral||LA20_0==FALSE||LA20_0==FUNCTION||LA20_0==HexIntegerLiteral||LA20_0==INC||LA20_0==INV||LA20_0==Identifier||(LA20_0>=LBRACE && LA20_0<=LBRACK)||LA20_0==LPAREN||(LA20_0>=NEW && LA20_0<=NOT)||LA20_0==NULL||LA20_0==OctalIntegerLiteral||LA20_0==RegularExpressionLiteral||LA20_0==SUB||LA20_0==StringLiteral||LA20_0==THIS||LA20_0==TRUE||LA20_0==TYPEOF||LA20_0==VOID))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:864:4: first= assignmentExpression ( COMMA follow= assignmentExpression )*
				{
				DebugLocation(864, 9);
				PushFollow(Follow._assignmentExpression_in_generics4322);
				first=assignmentExpression();
				PopFollow();

				DebugLocation(865, 4);
				 generics.Add(first); 
				DebugLocation(866, 4);
				// EcmaScript.g:866:4: ( COMMA follow= assignmentExpression )*
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if ((LA19_0==COMMA))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch ( alt19 )
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:867:5: COMMA follow= assignmentExpression
						{
						DebugLocation(867, 5);
						Match(input,COMMA,Follow._COMMA_in_generics4338); 
						DebugLocation(868, 11);
						PushFollow(Follow._assignmentExpression_in_generics4346);
						follow=assignmentExpression();
						PopFollow();

						DebugLocation(869, 5);
						 generics.Add(follow); 

						}
						break;

					default:
						goto loop19;
					}
				}

				loop19:
					;

				} finally { DebugExitSubRule(19); }


				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(872, 3);
			Match(input,RBRACE,Follow._RBRACE_in_generics4367); 

			}


				value = generics.ToReadOnly();

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("generics", 21);
			LeaveRule("generics", 21);
			LeaveRule_generics();
		}
		DebugLocation(873, 1);
		} finally { DebugExitRule(GrammarFileName, "generics"); }
		return value;

	}
	// $ANTLR end "generics"


	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();

	// $ANTLR start "leftHandSideExpression"
	// EcmaScript.g:875:1: leftHandSideExpression returns [ExpressionSyntax value] : ( NEW )? mem= memberExpression ( (gen= generics )? arg= arguments | LBRACK exp= expression RBRACK | DOT id= Identifier )* ;
	[GrammarRule("leftHandSideExpression")]
	private ExpressionSyntax leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 22);
		TraceIn("leftHandSideExpression", 22);
		ExpressionSyntax value = default(ExpressionSyntax);

		IToken id = default(IToken);
		ExpressionSyntax mem = default(ExpressionSyntax);
		ReadOnlyArray<ExpressionSyntax> gen = default(ReadOnlyArray<ExpressionSyntax>);
		ReadOnlyArray<MethodArgument> arg = default(ReadOnlyArray<MethodArgument>);
		ExpressionSyntax exp = default(ExpressionSyntax);


			var gens = ReadOnlyArray<ExpressionSyntax>.Empty;
		    bool isNew = false;

		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(875, 1);
		try
		{
			// EcmaScript.g:884:2: ( ( NEW )? mem= memberExpression ( (gen= generics )? arg= arguments | LBRACK exp= expression RBRACK | DOT id= Identifier )* )
			DebugEnterAlt(1);
			// EcmaScript.g:885:9: ( NEW )? mem= memberExpression ( (gen= generics )? arg= arguments | LBRACK exp= expression RBRACK | DOT id= Identifier )*
			{
			DebugLocation(885, 9);
			// EcmaScript.g:885:9: ( NEW )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==NEW))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:886:13: NEW
				{
				DebugLocation(886, 13);
				Match(input,NEW,Follow._NEW_in_leftHandSideExpression4414); 
				DebugLocation(887, 13);
				 isNew = true; 

				}
				break;

			}
			} finally { DebugExitSubRule(21); }

			DebugLocation(889, 9);
			PushFollow(Follow._memberExpression_in_leftHandSideExpression4448);
			mem=memberExpression();
			PopFollow();

			DebugLocation(890, 9);
			 value = mem; 
			DebugLocation(891, 6);
			// EcmaScript.g:891:6: ( (gen= generics )? arg= arguments | LBRACK exp= expression RBRACK | DOT id= Identifier )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=4;
				try { DebugEnterDecision(23, false);
				switch (input.LA(1))
				{
				case LBRACE:
				case LPAREN:
					{
					alt23 = 1;
					}
					break;
				case LBRACK:
					{
					alt23 = 2;
					}
					break;
				case DOT:
					{
					alt23 = 3;
					}
					break;

				}

				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:892:7: (gen= generics )? arg= arguments
					{
					DebugLocation(892, 7);
					// EcmaScript.g:892:7: (gen= generics )?
					int alt22=2;
					try { DebugEnterSubRule(22);
					try { DebugEnterDecision(22, false);
					int LA22_0 = input.LA(1);

					if ((LA22_0==LBRACE))
					{
						alt22 = 1;
					}
					} finally { DebugExitDecision(22); }
					switch (alt22)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:893:17: gen= generics
						{
						DebugLocation(893, 20);
						PushFollow(Follow._generics_in_leftHandSideExpression4493);
						gen=generics();
						PopFollow();

						DebugLocation(894, 17);
						 gens = gen; 

						}
						break;

					}
					} finally { DebugExitSubRule(22); }

					DebugLocation(896, 16);
					PushFollow(Follow._arguments_in_leftHandSideExpression4542);
					arg=arguments();
					PopFollow();

					DebugLocation(897, 13);

					                value = _builder.BuildMethodCall(
					                    value,
					                    arg,
					                    gens
					                );

					                if (isNew)
					                {
					                    isNew = false;
					                    value = _builder.BuildNew(value);
					                }
					            

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// EcmaScript.g:912:13: LBRACK exp= expression RBRACK
					{
					DebugLocation(912, 13);
					Match(input,LBRACK,Follow._LBRACK_in_leftHandSideExpression4577); 
					DebugLocation(912, 23);
					PushFollow(Follow._expression_in_leftHandSideExpression4581);
					exp=expression();
					PopFollow();

					DebugLocation(912, 35);
					Match(input,RBRACK,Follow._RBRACK_in_leftHandSideExpression4583); 
					DebugLocation(913, 13);

					                value = _builder.BuildIndexer(
					                    value,
					                    exp
					                );
					            

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// EcmaScript.g:921:13: DOT id= Identifier
					{
					DebugLocation(921, 13);
					Match(input,DOT,Follow._DOT_in_leftHandSideExpression4620); 
					DebugLocation(921, 19);
					id=(IToken)Match(input,Identifier,Follow._Identifier_in_leftHandSideExpression4624); 
					DebugLocation(922, 13);

					                value = _builder.BuildProperty(
					                    value,
					                    id.Text
					                );
					            

					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }


			}


			    if (isNew)
			        value = _builder.BuildNew(value);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("leftHandSideExpression", 22);
			LeaveRule("leftHandSideExpression", 22);
			LeaveRule_leftHandSideExpression();
		}
		DebugLocation(929, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return value;

	}
	// $ANTLR end "leftHandSideExpression"


	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();

	// $ANTLR start "postfixExpression"
	// EcmaScript.g:941:1: postfixExpression returns [ExpressionSyntax value] : left= leftHandSideExpression (post= postfixOperator )? ;
	[GrammarRule("postfixExpression")]
	private ExpressionSyntax postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 23);
		TraceIn("postfixExpression", 23);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		SyntaxExpressionType post = default(SyntaxExpressionType);

		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(941, 1);
		try
		{
			// EcmaScript.g:942:2: (left= leftHandSideExpression (post= postfixOperator )? )
			DebugEnterAlt(1);
			// EcmaScript.g:943:3: left= leftHandSideExpression (post= postfixOperator )?
			{
			DebugLocation(943, 7);
			PushFollow(Follow._leftHandSideExpression_in_postfixExpression4672);
			left=leftHandSideExpression();
			PopFollow();

			DebugLocation(944, 3);

						value = left;
						if (input.LA(1) == INC || input.LA(1) == DEC)
							PromoteEol();
					
			DebugLocation(949, 3);
			// EcmaScript.g:949:3: (post= postfixOperator )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==DEC||LA24_0==INC))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:950:4: post= postfixOperator
				{
				DebugLocation(950, 8);
				PushFollow(Follow._postfixOperator_in_postfixExpression4687);
				post=postfixOperator();
				PopFollow();

				DebugLocation(951, 4);
				 value = _builder.BuildUnary(post, value); 

				}
				break;

			}
			} finally { DebugExitSubRule(24); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("postfixExpression", 23);
			LeaveRule("postfixExpression", 23);
			LeaveRule_postfixExpression();
		}
		DebugLocation(953, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return value;

	}
	// $ANTLR end "postfixExpression"


	partial void EnterRule_postfixOperator();
	partial void LeaveRule_postfixOperator();

	// $ANTLR start "postfixOperator"
	// EcmaScript.g:955:1: postfixOperator returns [SyntaxExpressionType value] : (op= INC |op= DEC );
	[GrammarRule("postfixOperator")]
	private SyntaxExpressionType postfixOperator()
	{
		EnterRule_postfixOperator();
		EnterRule("postfixOperator", 24);
		TraceIn("postfixOperator", 24);
		SyntaxExpressionType value = default(SyntaxExpressionType);

		IToken op = default(IToken);

		try { DebugEnterRule(GrammarFileName, "postfixOperator");
		DebugLocation(955, 1);
		try
		{
			// EcmaScript.g:956:2: (op= INC |op= DEC )
			int alt25=2;
			try { DebugEnterDecision(25, false);
			int LA25_0 = input.LA(1);

			if ((LA25_0==INC))
			{
				alt25 = 1;
			}
			else if ((LA25_0==DEC))
			{
				alt25 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:957:3: op= INC
				{
				DebugLocation(957, 5);
				op=(IToken)Match(input,INC,Follow._INC_in_postfixOperator4717); 
				DebugLocation(958, 3);
				 op.Type = PINC; value = SyntaxExpressionType.PostIncrementAssign; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:960:3: op= DEC
				{
				DebugLocation(960, 5);
				op=(IToken)Match(input,DEC,Follow._DEC_in_postfixOperator4730); 
				DebugLocation(961, 3);
				 op.Type = PDEC; value = SyntaxExpressionType.PostDecrementAssign; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("postfixOperator", 24);
			LeaveRule("postfixOperator", 24);
			LeaveRule_postfixOperator();
		}
		DebugLocation(962, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixOperator"); }
		return value;

	}
	// $ANTLR end "postfixOperator"


	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// EcmaScript.g:968:1: unaryExpression returns [ExpressionSyntax value] : (post= postfixExpression |op= unaryOperator exp= unaryExpression );
	[GrammarRule("unaryExpression")]
	private ExpressionSyntax unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 25);
		TraceIn("unaryExpression", 25);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax post = default(ExpressionSyntax);
		SyntaxExpressionType op = default(SyntaxExpressionType);
		ExpressionSyntax exp = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(968, 1);
		try
		{
			// EcmaScript.g:969:2: (post= postfixExpression |op= unaryOperator exp= unaryExpression )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==DecimalLiteral||LA26_0==FALSE||LA26_0==FUNCTION||LA26_0==HexIntegerLiteral||LA26_0==Identifier||(LA26_0>=LBRACE && LA26_0<=LBRACK)||LA26_0==LPAREN||LA26_0==NEW||LA26_0==NULL||LA26_0==OctalIntegerLiteral||LA26_0==RegularExpressionLiteral||LA26_0==StringLiteral||LA26_0==THIS||LA26_0==TRUE))
			{
				alt26 = 1;
			}
			else if ((LA26_0==ADD||LA26_0==DEC||LA26_0==DELETE||LA26_0==INC||LA26_0==INV||LA26_0==NOT||LA26_0==SUB||LA26_0==TYPEOF||LA26_0==VOID))
			{
				alt26 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:969:4: post= postfixExpression
				{
				DebugLocation(969, 8);
				PushFollow(Follow._postfixExpression_in_unaryExpression4755);
				post=postfixExpression();
				PopFollow();

				DebugLocation(969, 27);
				 value = post; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:970:4: op= unaryOperator exp= unaryExpression
				{
				DebugLocation(970, 6);
				PushFollow(Follow._unaryOperator_in_unaryExpression4764);
				op=unaryOperator();
				PopFollow();

				DebugLocation(970, 24);
				PushFollow(Follow._unaryExpression_in_unaryExpression4768);
				exp=unaryExpression();
				PopFollow();

				DebugLocation(970, 41);
				 value = _builder.BuildUnary(op, exp); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryExpression", 25);
			LeaveRule("unaryExpression", 25);
			LeaveRule_unaryExpression();
		}
		DebugLocation(971, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return value;

	}
	// $ANTLR end "unaryExpression"


	partial void EnterRule_unaryOperator();
	partial void LeaveRule_unaryOperator();

	// $ANTLR start "unaryOperator"
	// EcmaScript.g:973:1: unaryOperator returns [SyntaxExpressionType value] : ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT );
	[GrammarRule("unaryOperator")]
	private SyntaxExpressionType unaryOperator()
	{
		EnterRule_unaryOperator();
		EnterRule("unaryOperator", 26);
		TraceIn("unaryOperator", 26);
		SyntaxExpressionType value = default(SyntaxExpressionType);

		IToken op = default(IToken);

		try { DebugEnterRule(GrammarFileName, "unaryOperator");
		DebugLocation(973, 1);
		try
		{
			// EcmaScript.g:974:2: ( DELETE | VOID | TYPEOF | INC | DEC |op= ADD |op= SUB | INV | NOT )
			int alt27=9;
			try { DebugEnterDecision(27, false);
			switch (input.LA(1))
			{
			case DELETE:
				{
				alt27 = 1;
				}
				break;
			case VOID:
				{
				alt27 = 2;
				}
				break;
			case TYPEOF:
				{
				alt27 = 3;
				}
				break;
			case INC:
				{
				alt27 = 4;
				}
				break;
			case DEC:
				{
				alt27 = 5;
				}
				break;
			case ADD:
				{
				alt27 = 6;
				}
				break;
			case SUB:
				{
				alt27 = 7;
				}
				break;
			case INV:
				{
				alt27 = 8;
				}
				break;
			case NOT:
				{
				alt27 = 9;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:974:4: DELETE
				{
				DebugLocation(974, 4);
				Match(input,DELETE,Follow._DELETE_in_unaryOperator4786); 
				DebugLocation(974, 11);
				 value = SyntaxExpressionType.Delete; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:975:4: VOID
				{
				DebugLocation(975, 4);
				Match(input,VOID,Follow._VOID_in_unaryOperator4793); 
				DebugLocation(975, 9);
				 value = SyntaxExpressionType.Void; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:976:4: TYPEOF
				{
				DebugLocation(976, 4);
				Match(input,TYPEOF,Follow._TYPEOF_in_unaryOperator4800); 
				DebugLocation(976, 11);
				 value = SyntaxExpressionType.TypeOf; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:977:4: INC
				{
				DebugLocation(977, 4);
				Match(input,INC,Follow._INC_in_unaryOperator4807); 
				DebugLocation(977, 8);
				 value = SyntaxExpressionType.PreIncrementAssign; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// EcmaScript.g:978:4: DEC
				{
				DebugLocation(978, 4);
				Match(input,DEC,Follow._DEC_in_unaryOperator4814); 
				DebugLocation(978, 8);
				 value = SyntaxExpressionType.PreDecrementAssign; 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// EcmaScript.g:979:4: op= ADD
				{
				DebugLocation(979, 6);
				op=(IToken)Match(input,ADD,Follow._ADD_in_unaryOperator4823); 
				DebugLocation(979, 11);
				 op.Type = POS; value = SyntaxExpressionType.UnaryPlus; 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// EcmaScript.g:980:4: op= SUB
				{
				DebugLocation(980, 6);
				op=(IToken)Match(input,SUB,Follow._SUB_in_unaryOperator4832); 
				DebugLocation(980, 11);
				 op.Type = NEG; value = SyntaxExpressionType.Negate; 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// EcmaScript.g:981:4: INV
				{
				DebugLocation(981, 4);
				Match(input,INV,Follow._INV_in_unaryOperator4839); 
				DebugLocation(981, 8);
				 value = SyntaxExpressionType.BitwiseNot; 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// EcmaScript.g:982:4: NOT
				{
				DebugLocation(982, 4);
				Match(input,NOT,Follow._NOT_in_unaryOperator4846); 
				DebugLocation(982, 8);
				 value = SyntaxExpressionType.Not; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("unaryOperator", 26);
			LeaveRule("unaryOperator", 26);
			LeaveRule_unaryOperator();
		}
		DebugLocation(983, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryOperator"); }
		return value;

	}
	// $ANTLR end "unaryOperator"


	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// EcmaScript.g:989:1: multiplicativeExpression returns [ExpressionSyntax value] : left= unaryExpression ( ( MUL | DIV | MOD ) right= unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private ExpressionSyntax multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 27);
		TraceIn("multiplicativeExpression", 27);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(989, 1);
		try
		{
			// EcmaScript.g:993:2: (left= unaryExpression ( ( MUL | DIV | MOD ) right= unaryExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:994:3: left= unaryExpression ( ( MUL | DIV | MOD ) right= unaryExpression )*
			{
			DebugLocation(994, 7);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression4876);
			left=unaryExpression();
			PopFollow();

			DebugLocation(994, 24);
			 value = left; 
			DebugLocation(995, 3);
			// EcmaScript.g:995:3: ( ( MUL | DIV | MOD ) right= unaryExpression )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=2;
				try { DebugEnterDecision(29, false);
				int LA29_0 = input.LA(1);

				if ((LA29_0==DIV||LA29_0==MOD||LA29_0==MUL))
				{
					alt29 = 1;
				}


				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:996:4: ( MUL | DIV | MOD ) right= unaryExpression
					{
					DebugLocation(996, 4);
					// EcmaScript.g:996:4: ( MUL | DIV | MOD )
					int alt28=3;
					try { DebugEnterSubRule(28);
					try { DebugEnterDecision(28, false);
					switch (input.LA(1))
					{
					case MUL:
						{
						alt28 = 1;
						}
						break;
					case DIV:
						{
						alt28 = 2;
						}
						break;
					case MOD:
						{
						alt28 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:997:5: MUL
						{
						DebugLocation(997, 5);
						Match(input,MUL,Follow._MUL_in_multiplicativeExpression4894); 
						DebugLocation(997, 9);
						 type= SyntaxExpressionType.Multiply; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:999:5: DIV
						{
						DebugLocation(999, 5);
						Match(input,DIV,Follow._DIV_in_multiplicativeExpression4908); 
						DebugLocation(999, 9);
						 type= SyntaxExpressionType.Divide; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// EcmaScript.g:1001:5: MOD
						{
						DebugLocation(1001, 5);
						Match(input,MOD,Follow._MOD_in_multiplicativeExpression4921); 
						DebugLocation(1001, 9);
						 type= SyntaxExpressionType.Modulo; 

						}
						break;

					}
					} finally { DebugExitSubRule(28); }

					DebugLocation(1003, 9);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression4935);
					right=unaryExpression();
					PopFollow();

					DebugLocation(1004, 4);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("multiplicativeExpression", 27);
			LeaveRule("multiplicativeExpression", 27);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(1006, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return value;

	}
	// $ANTLR end "multiplicativeExpression"


	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// EcmaScript.g:1012:1: additiveExpression returns [ExpressionSyntax value] : left= multiplicativeExpression ( ( ADD | SUB ) right= multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private ExpressionSyntax additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 28);
		TraceIn("additiveExpression", 28);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(1012, 1);
		try
		{
			// EcmaScript.g:1016:2: (left= multiplicativeExpression ( ( ADD | SUB ) right= multiplicativeExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1017:3: left= multiplicativeExpression ( ( ADD | SUB ) right= multiplicativeExpression )*
			{
			DebugLocation(1017, 7);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression4973);
			left=multiplicativeExpression();
			PopFollow();

			DebugLocation(1018, 3);
			 value = left; 
			DebugLocation(1019, 3);
			// EcmaScript.g:1019:3: ( ( ADD | SUB ) right= multiplicativeExpression )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_0 = input.LA(1);

				if ((LA31_0==ADD||LA31_0==SUB))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1020:4: ( ADD | SUB ) right= multiplicativeExpression
					{
					DebugLocation(1020, 4);
					// EcmaScript.g:1020:4: ( ADD | SUB )
					int alt30=2;
					try { DebugEnterSubRule(30);
					try { DebugEnterDecision(30, false);
					int LA30_0 = input.LA(1);

					if ((LA30_0==ADD))
					{
						alt30 = 1;
					}
					else if ((LA30_0==SUB))
					{
						alt30 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 30, 0, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(30); }
					switch (alt30)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1021:5: ADD
						{
						DebugLocation(1021, 5);
						Match(input,ADD,Follow._ADD_in_additiveExpression4992); 
						DebugLocation(1021, 9);
						 type= SyntaxExpressionType.Add; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:1023:5: SUB
						{
						DebugLocation(1023, 5);
						Match(input,SUB,Follow._SUB_in_additiveExpression5005); 
						DebugLocation(1023, 9);
						 type= SyntaxExpressionType.Subtract; 

						}
						break;

					}
					} finally { DebugExitSubRule(30); }

					DebugLocation(1025, 9);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression5019);
					right=multiplicativeExpression();
					PopFollow();

					DebugLocation(1026, 4);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("additiveExpression", 28);
			LeaveRule("additiveExpression", 28);
			LeaveRule_additiveExpression();
		}
		DebugLocation(1028, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return value;

	}
	// $ANTLR end "additiveExpression"


	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();

	// $ANTLR start "shiftExpression"
	// EcmaScript.g:1034:1: shiftExpression returns [ExpressionSyntax value] : left= additiveExpression ( ( SHL | SHR | SHU ) right= additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private ExpressionSyntax shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 29);
		TraceIn("shiftExpression", 29);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(1034, 1);
		try
		{
			// EcmaScript.g:1038:2: (left= additiveExpression ( ( SHL | SHR | SHU ) right= additiveExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1039:3: left= additiveExpression ( ( SHL | SHR | SHU ) right= additiveExpression )*
			{
			DebugLocation(1039, 7);
			PushFollow(Follow._additiveExpression_in_shiftExpression5058);
			left=additiveExpression();
			PopFollow();

			DebugLocation(1040, 3);
			 value = left; 
			DebugLocation(1041, 3);
			// EcmaScript.g:1041:3: ( ( SHL | SHR | SHU ) right= additiveExpression )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_0 = input.LA(1);

				if ((LA33_0==SHL||LA33_0==SHR||LA33_0==SHU))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1042:4: ( SHL | SHR | SHU ) right= additiveExpression
					{
					DebugLocation(1042, 4);
					// EcmaScript.g:1042:4: ( SHL | SHR | SHU )
					int alt32=3;
					try { DebugEnterSubRule(32);
					try { DebugEnterDecision(32, false);
					switch (input.LA(1))
					{
					case SHL:
						{
						alt32 = 1;
						}
						break;
					case SHR:
						{
						alt32 = 2;
						}
						break;
					case SHU:
						{
						alt32 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 32, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(32); }
					switch (alt32)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1043:5: SHL
						{
						DebugLocation(1043, 5);
						Match(input,SHL,Follow._SHL_in_shiftExpression5077); 
						DebugLocation(1043, 9);
						 type= SyntaxExpressionType.LeftShift; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:1045:5: SHR
						{
						DebugLocation(1045, 5);
						Match(input,SHR,Follow._SHR_in_shiftExpression5090); 
						DebugLocation(1045, 9);
						 type= SyntaxExpressionType.RightShift; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// EcmaScript.g:1047:5: SHU
						{
						DebugLocation(1047, 5);
						Match(input,SHU,Follow._SHU_in_shiftExpression5103); 
						DebugLocation(1047, 9);
						 type= SyntaxExpressionType.UnsignedRightShift; 

						}
						break;

					}
					} finally { DebugExitSubRule(32); }

					DebugLocation(1049, 9);
					PushFollow(Follow._additiveExpression_in_shiftExpression5117);
					right=additiveExpression();
					PopFollow();

					DebugLocation(1050, 4);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("shiftExpression", 29);
			LeaveRule("shiftExpression", 29);
			LeaveRule_shiftExpression();
		}
		DebugLocation(1052, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return value;

	}
	// $ANTLR end "shiftExpression"


	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// EcmaScript.g:1058:1: relationalExpression returns [ExpressionSyntax value] : left= shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) right= shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private ExpressionSyntax relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 30);
		TraceIn("relationalExpression", 30);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(1058, 1);
		try
		{
			// EcmaScript.g:1062:2: (left= shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) right= shiftExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1063:3: left= shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) right= shiftExpression )*
			{
			DebugLocation(1063, 7);
			PushFollow(Follow._shiftExpression_in_relationalExpression5156);
			left=shiftExpression();
			PopFollow();

			DebugLocation(1063, 24);
			 value = left; 
			DebugLocation(1064, 3);
			// EcmaScript.g:1064:3: ( ( LT | GT | LTE | GTE | INSTANCEOF | IN ) right= shiftExpression )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_0 = input.LA(1);

				if (((LA35_0>=GT && LA35_0<=GTE)||LA35_0==IN||LA35_0==INSTANCEOF||(LA35_0>=LT && LA35_0<=LTE)))
				{
					alt35 = 1;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1065:4: ( LT | GT | LTE | GTE | INSTANCEOF | IN ) right= shiftExpression
					{
					DebugLocation(1065, 4);
					// EcmaScript.g:1065:4: ( LT | GT | LTE | GTE | INSTANCEOF | IN )
					int alt34=6;
					try { DebugEnterSubRule(34);
					try { DebugEnterDecision(34, false);
					switch (input.LA(1))
					{
					case LT:
						{
						alt34 = 1;
						}
						break;
					case GT:
						{
						alt34 = 2;
						}
						break;
					case LTE:
						{
						alt34 = 3;
						}
						break;
					case GTE:
						{
						alt34 = 4;
						}
						break;
					case INSTANCEOF:
						{
						alt34 = 5;
						}
						break;
					case IN:
						{
						alt34 = 6;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(34); }
					switch (alt34)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1066:5: LT
						{
						DebugLocation(1066, 5);
						Match(input,LT,Follow._LT_in_relationalExpression5173); 
						DebugLocation(1066, 8);
						 type= SyntaxExpressionType.LessThan; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:1068:5: GT
						{
						DebugLocation(1068, 5);
						Match(input,GT,Follow._GT_in_relationalExpression5186); 
						DebugLocation(1068, 8);
						 type= SyntaxExpressionType.GreaterThan; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// EcmaScript.g:1070:5: LTE
						{
						DebugLocation(1070, 5);
						Match(input,LTE,Follow._LTE_in_relationalExpression5199); 
						DebugLocation(1070, 9);
						 type= SyntaxExpressionType.LessThanOrEqual; 

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// EcmaScript.g:1072:5: GTE
						{
						DebugLocation(1072, 5);
						Match(input,GTE,Follow._GTE_in_relationalExpression5212); 
						DebugLocation(1072, 9);
						 type= SyntaxExpressionType.GreaterThanOrEqual; 

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// EcmaScript.g:1074:5: INSTANCEOF
						{
						DebugLocation(1074, 5);
						Match(input,INSTANCEOF,Follow._INSTANCEOF_in_relationalExpression5225); 
						DebugLocation(1074, 16);
						 type= SyntaxExpressionType.InstanceOf;  

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// EcmaScript.g:1076:5: IN
						{
						DebugLocation(1076, 5);
						Match(input,IN,Follow._IN_in_relationalExpression5238); 
						DebugLocation(1076, 8);
						 type= SyntaxExpressionType.In;  

						}
						break;

					}
					} finally { DebugExitSubRule(34); }

					DebugLocation(1078, 9);
					PushFollow(Follow._shiftExpression_in_relationalExpression5252);
					right=shiftExpression();
					PopFollow();

					DebugLocation(1079, 4);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("relationalExpression", 30);
			LeaveRule("relationalExpression", 30);
			LeaveRule_relationalExpression();
		}
		DebugLocation(1081, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return value;

	}
	// $ANTLR end "relationalExpression"


	partial void EnterRule_relationalExpressionNoIn();
	partial void LeaveRule_relationalExpressionNoIn();

	// $ANTLR start "relationalExpressionNoIn"
	// EcmaScript.g:1083:1: relationalExpressionNoIn returns [ExpressionSyntax value] : left= shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) right= shiftExpression )* ;
	[GrammarRule("relationalExpressionNoIn")]
	private ExpressionSyntax relationalExpressionNoIn()
	{
		EnterRule_relationalExpressionNoIn();
		EnterRule("relationalExpressionNoIn", 31);
		TraceIn("relationalExpressionNoIn", 31);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
		DebugLocation(1083, 1);
		try
		{
			// EcmaScript.g:1087:2: (left= shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) right= shiftExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1088:3: left= shiftExpression ( ( LT | GT | LTE | GTE | INSTANCEOF ) right= shiftExpression )*
			{
			DebugLocation(1088, 7);
			PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn5286);
			left=shiftExpression();
			PopFollow();

			DebugLocation(1088, 24);
			 value = left; 
			DebugLocation(1089, 3);
			// EcmaScript.g:1089:3: ( ( LT | GT | LTE | GTE | INSTANCEOF ) right= shiftExpression )*
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_0 = input.LA(1);

				if (((LA37_0>=GT && LA37_0<=GTE)||LA37_0==INSTANCEOF||(LA37_0>=LT && LA37_0<=LTE)))
				{
					alt37 = 1;
				}


				} finally { DebugExitDecision(37); }
				switch ( alt37 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1090:4: ( LT | GT | LTE | GTE | INSTANCEOF ) right= shiftExpression
					{
					DebugLocation(1090, 4);
					// EcmaScript.g:1090:4: ( LT | GT | LTE | GTE | INSTANCEOF )
					int alt36=5;
					try { DebugEnterSubRule(36);
					try { DebugEnterDecision(36, false);
					switch (input.LA(1))
					{
					case LT:
						{
						alt36 = 1;
						}
						break;
					case GT:
						{
						alt36 = 2;
						}
						break;
					case LTE:
						{
						alt36 = 3;
						}
						break;
					case GTE:
						{
						alt36 = 4;
						}
						break;
					case INSTANCEOF:
						{
						alt36 = 5;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 36, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(36); }
					switch (alt36)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1091:5: LT
						{
						DebugLocation(1091, 5);
						Match(input,LT,Follow._LT_in_relationalExpressionNoIn5303); 
						DebugLocation(1091, 8);
						 type= SyntaxExpressionType.LessThan; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:1093:5: GT
						{
						DebugLocation(1093, 5);
						Match(input,GT,Follow._GT_in_relationalExpressionNoIn5316); 
						DebugLocation(1093, 8);
						 type= SyntaxExpressionType.GreaterThan; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// EcmaScript.g:1095:5: LTE
						{
						DebugLocation(1095, 5);
						Match(input,LTE,Follow._LTE_in_relationalExpressionNoIn5329); 
						DebugLocation(1095, 9);
						 type= SyntaxExpressionType.LessThanOrEqual; 

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// EcmaScript.g:1097:5: GTE
						{
						DebugLocation(1097, 5);
						Match(input,GTE,Follow._GTE_in_relationalExpressionNoIn5342); 
						DebugLocation(1097, 9);
						 type= SyntaxExpressionType.GreaterThanOrEqual; 

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// EcmaScript.g:1099:5: INSTANCEOF
						{
						DebugLocation(1099, 5);
						Match(input,INSTANCEOF,Follow._INSTANCEOF_in_relationalExpressionNoIn5355); 
						DebugLocation(1099, 16);
						 type= SyntaxExpressionType.InstanceOf;  

						}
						break;

					}
					} finally { DebugExitSubRule(36); }

					DebugLocation(1101, 9);
					PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn5369);
					right=shiftExpression();
					PopFollow();

					DebugLocation(1101, 26);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop37;
				}
			}

			loop37:
				;

			} finally { DebugExitSubRule(37); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("relationalExpressionNoIn", 31);
			LeaveRule("relationalExpressionNoIn", 31);
			LeaveRule_relationalExpressionNoIn();
		}
		DebugLocation(1103, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "relationalExpressionNoIn"


	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();

	// $ANTLR start "equalityExpression"
	// EcmaScript.g:1109:1: equalityExpression returns [ExpressionSyntax value] : left= relationalExpression ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private ExpressionSyntax equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 32);
		TraceIn("equalityExpression", 32);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(1109, 1);
		try
		{
			// EcmaScript.g:1113:2: (left= relationalExpression ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1114:3: left= relationalExpression ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpression )*
			{
			DebugLocation(1114, 7);
			PushFollow(Follow._relationalExpression_in_equalityExpression5405);
			left=relationalExpression();
			PopFollow();

			DebugLocation(1114, 29);
			 value = left; 
			DebugLocation(1115, 3);
			// EcmaScript.g:1115:3: ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpression )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_0 = input.LA(1);

				if ((LA39_0==EQ||LA39_0==NEQ||LA39_0==NSAME||LA39_0==SAME))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1116:4: ( EQ | NEQ | SAME | NSAME ) right= relationalExpression
					{
					DebugLocation(1116, 4);
					// EcmaScript.g:1116:4: ( EQ | NEQ | SAME | NSAME )
					int alt38=4;
					try { DebugEnterSubRule(38);
					try { DebugEnterDecision(38, false);
					switch (input.LA(1))
					{
					case EQ:
						{
						alt38 = 1;
						}
						break;
					case NEQ:
						{
						alt38 = 2;
						}
						break;
					case SAME:
						{
						alt38 = 3;
						}
						break;
					case NSAME:
						{
						alt38 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 38, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(38); }
					switch (alt38)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1117:5: EQ
						{
						DebugLocation(1117, 5);
						Match(input,EQ,Follow._EQ_in_equalityExpression5422); 
						DebugLocation(1117, 8);
						 type= SyntaxExpressionType.Equal; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:1119:5: NEQ
						{
						DebugLocation(1119, 5);
						Match(input,NEQ,Follow._NEQ_in_equalityExpression5435); 
						DebugLocation(1119, 9);
						 type= SyntaxExpressionType.NotEqual; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// EcmaScript.g:1121:5: SAME
						{
						DebugLocation(1121, 5);
						Match(input,SAME,Follow._SAME_in_equalityExpression5448); 
						DebugLocation(1121, 10);
						 type= SyntaxExpressionType.Same; 

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// EcmaScript.g:1123:5: NSAME
						{
						DebugLocation(1123, 5);
						Match(input,NSAME,Follow._NSAME_in_equalityExpression5461); 
						DebugLocation(1123, 11);
						 type= SyntaxExpressionType.NotSame; 

						}
						break;

					}
					} finally { DebugExitSubRule(38); }

					DebugLocation(1125, 9);
					PushFollow(Follow._relationalExpression_in_equalityExpression5475);
					right=relationalExpression();
					PopFollow();

					DebugLocation(1126, 4);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("equalityExpression", 32);
			LeaveRule("equalityExpression", 32);
			LeaveRule_equalityExpression();
		}
		DebugLocation(1128, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return value;

	}
	// $ANTLR end "equalityExpression"


	partial void EnterRule_equalityExpressionNoIn();
	partial void LeaveRule_equalityExpressionNoIn();

	// $ANTLR start "equalityExpressionNoIn"
	// EcmaScript.g:1130:1: equalityExpressionNoIn returns [ExpressionSyntax value] : left= relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpressionNoIn )* ;
	[GrammarRule("equalityExpressionNoIn")]
	private ExpressionSyntax equalityExpressionNoIn()
	{
		EnterRule_equalityExpressionNoIn();
		EnterRule("equalityExpressionNoIn", 33);
		TraceIn("equalityExpressionNoIn", 33);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);


			var type = SyntaxExpressionType.Unknown;

		try { DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
		DebugLocation(1130, 1);
		try
		{
			// EcmaScript.g:1134:2: (left= relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1135:3: left= relationalExpressionNoIn ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpressionNoIn )*
			{
			DebugLocation(1135, 7);
			PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn5509);
			left=relationalExpressionNoIn();
			PopFollow();

			DebugLocation(1135, 33);
			 value = left; 
			DebugLocation(1136, 3);
			// EcmaScript.g:1136:3: ( ( EQ | NEQ | SAME | NSAME ) right= relationalExpressionNoIn )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_0 = input.LA(1);

				if ((LA41_0==EQ||LA41_0==NEQ||LA41_0==NSAME||LA41_0==SAME))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1137:4: ( EQ | NEQ | SAME | NSAME ) right= relationalExpressionNoIn
					{
					DebugLocation(1137, 4);
					// EcmaScript.g:1137:4: ( EQ | NEQ | SAME | NSAME )
					int alt40=4;
					try { DebugEnterSubRule(40);
					try { DebugEnterDecision(40, false);
					switch (input.LA(1))
					{
					case EQ:
						{
						alt40 = 1;
						}
						break;
					case NEQ:
						{
						alt40 = 2;
						}
						break;
					case SAME:
						{
						alt40 = 3;
						}
						break;
					case NSAME:
						{
						alt40 = 4;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 40, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(40); }
					switch (alt40)
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1138:5: EQ
						{
						DebugLocation(1138, 5);
						Match(input,EQ,Follow._EQ_in_equalityExpressionNoIn5526); 
						DebugLocation(1138, 8);
						 type= SyntaxExpressionType.Equal; 

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// EcmaScript.g:1140:5: NEQ
						{
						DebugLocation(1140, 5);
						Match(input,NEQ,Follow._NEQ_in_equalityExpressionNoIn5539); 
						DebugLocation(1140, 9);
						 type= SyntaxExpressionType.NotEqual; 

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// EcmaScript.g:1142:5: SAME
						{
						DebugLocation(1142, 5);
						Match(input,SAME,Follow._SAME_in_equalityExpressionNoIn5552); 
						DebugLocation(1142, 10);
						 type= SyntaxExpressionType.Same; 

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// EcmaScript.g:1144:5: NSAME
						{
						DebugLocation(1144, 5);
						Match(input,NSAME,Follow._NSAME_in_equalityExpressionNoIn5565); 
						DebugLocation(1144, 11);
						 type= SyntaxExpressionType.NotSame; 

						}
						break;

					}
					} finally { DebugExitSubRule(40); }

					DebugLocation(1146, 9);
					PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn5579);
					right=relationalExpressionNoIn();
					PopFollow();

					DebugLocation(1147, 4);
					 value = _builder.BuildBinary(type, value, right); 

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("equalityExpressionNoIn", 33);
			LeaveRule("equalityExpressionNoIn", 33);
			LeaveRule_equalityExpressionNoIn();
		}
		DebugLocation(1149, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "equalityExpressionNoIn"


	partial void EnterRule_bitwiseANDExpression();
	partial void LeaveRule_bitwiseANDExpression();

	// $ANTLR start "bitwiseANDExpression"
	// EcmaScript.g:1155:1: bitwiseANDExpression returns [ExpressionSyntax value] : left= equalityExpression ( AND right= equalityExpression )* ;
	[GrammarRule("bitwiseANDExpression")]
	private ExpressionSyntax bitwiseANDExpression()
	{
		EnterRule_bitwiseANDExpression();
		EnterRule("bitwiseANDExpression", 34);
		TraceIn("bitwiseANDExpression", 34);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
		DebugLocation(1155, 1);
		try
		{
			// EcmaScript.g:1156:2: (left= equalityExpression ( AND right= equalityExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1157:3: left= equalityExpression ( AND right= equalityExpression )*
			{
			DebugLocation(1157, 7);
			PushFollow(Follow._equalityExpression_in_bitwiseANDExpression5614);
			left=equalityExpression();
			PopFollow();

			DebugLocation(1158, 3);
			 value = left; 
			DebugLocation(1159, 3);
			// EcmaScript.g:1159:3: ( AND right= equalityExpression )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_0 = input.LA(1);

				if ((LA42_0==AND))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1160:4: AND right= equalityExpression
					{
					DebugLocation(1160, 4);
					Match(input,AND,Follow._AND_in_bitwiseANDExpression5627); 
					DebugLocation(1160, 13);
					PushFollow(Follow._equalityExpression_in_bitwiseANDExpression5631);
					right=equalityExpression();
					PopFollow();

					DebugLocation(1161, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.BitwiseAnd, value, right); 

					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseANDExpression", 34);
			LeaveRule("bitwiseANDExpression", 34);
			LeaveRule_bitwiseANDExpression();
		}
		DebugLocation(1163, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
		return value;

	}
	// $ANTLR end "bitwiseANDExpression"


	partial void EnterRule_bitwiseANDExpressionNoIn();
	partial void LeaveRule_bitwiseANDExpressionNoIn();

	// $ANTLR start "bitwiseANDExpressionNoIn"
	// EcmaScript.g:1165:1: bitwiseANDExpressionNoIn returns [ExpressionSyntax value] : left= equalityExpressionNoIn ( AND right= equalityExpressionNoIn )* ;
	[GrammarRule("bitwiseANDExpressionNoIn")]
	private ExpressionSyntax bitwiseANDExpressionNoIn()
	{
		EnterRule_bitwiseANDExpressionNoIn();
		EnterRule("bitwiseANDExpressionNoIn", 35);
		TraceIn("bitwiseANDExpressionNoIn", 35);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
		DebugLocation(1165, 1);
		try
		{
			// EcmaScript.g:1166:2: (left= equalityExpressionNoIn ( AND right= equalityExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1167:3: left= equalityExpressionNoIn ( AND right= equalityExpressionNoIn )*
			{
			DebugLocation(1167, 7);
			PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5660);
			left=equalityExpressionNoIn();
			PopFollow();

			DebugLocation(1168, 3);
			 value = left; 
			DebugLocation(1169, 3);
			// EcmaScript.g:1169:3: ( AND right= equalityExpressionNoIn )*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_0 = input.LA(1);

				if ((LA43_0==AND))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1170:4: AND right= equalityExpressionNoIn
					{
					DebugLocation(1170, 4);
					Match(input,AND,Follow._AND_in_bitwiseANDExpressionNoIn5673); 
					DebugLocation(1170, 13);
					PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5677);
					right=equalityExpressionNoIn();
					PopFollow();

					DebugLocation(1171, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.BitwiseAnd, value, right); 

					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseANDExpressionNoIn", 35);
			LeaveRule("bitwiseANDExpressionNoIn", 35);
			LeaveRule_bitwiseANDExpressionNoIn();
		}
		DebugLocation(1173, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "bitwiseANDExpressionNoIn"


	partial void EnterRule_bitwiseXORExpression();
	partial void LeaveRule_bitwiseXORExpression();

	// $ANTLR start "bitwiseXORExpression"
	// EcmaScript.g:1175:1: bitwiseXORExpression returns [ExpressionSyntax value] : left= bitwiseANDExpression ( XOR right= bitwiseANDExpression )* ;
	[GrammarRule("bitwiseXORExpression")]
	private ExpressionSyntax bitwiseXORExpression()
	{
		EnterRule_bitwiseXORExpression();
		EnterRule("bitwiseXORExpression", 36);
		TraceIn("bitwiseXORExpression", 36);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
		DebugLocation(1175, 1);
		try
		{
			// EcmaScript.g:1176:2: (left= bitwiseANDExpression ( XOR right= bitwiseANDExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1177:3: left= bitwiseANDExpression ( XOR right= bitwiseANDExpression )*
			{
			DebugLocation(1177, 7);
			PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression5708);
			left=bitwiseANDExpression();
			PopFollow();

			DebugLocation(1178, 3);
			 value = left; 
			DebugLocation(1179, 3);
			// EcmaScript.g:1179:3: ( XOR right= bitwiseANDExpression )*
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_0 = input.LA(1);

				if ((LA44_0==XOR))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch ( alt44 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1180:4: XOR right= bitwiseANDExpression
					{
					DebugLocation(1180, 4);
					Match(input,XOR,Follow._XOR_in_bitwiseXORExpression5721); 
					DebugLocation(1180, 13);
					PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression5725);
					right=bitwiseANDExpression();
					PopFollow();

					DebugLocation(1181, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.BitwiseExclusiveOr, value, right); 

					}
					break;

				default:
					goto loop44;
				}
			}

			loop44:
				;

			} finally { DebugExitSubRule(44); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseXORExpression", 36);
			LeaveRule("bitwiseXORExpression", 36);
			LeaveRule_bitwiseXORExpression();
		}
		DebugLocation(1183, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
		return value;

	}
	// $ANTLR end "bitwiseXORExpression"


	partial void EnterRule_bitwiseXORExpressionNoIn();
	partial void LeaveRule_bitwiseXORExpressionNoIn();

	// $ANTLR start "bitwiseXORExpressionNoIn"
	// EcmaScript.g:1185:1: bitwiseXORExpressionNoIn returns [ExpressionSyntax value] : left= bitwiseANDExpressionNoIn ( XOR right= bitwiseANDExpressionNoIn )* ;
	[GrammarRule("bitwiseXORExpressionNoIn")]
	private ExpressionSyntax bitwiseXORExpressionNoIn()
	{
		EnterRule_bitwiseXORExpressionNoIn();
		EnterRule("bitwiseXORExpressionNoIn", 37);
		TraceIn("bitwiseXORExpressionNoIn", 37);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
		DebugLocation(1185, 1);
		try
		{
			// EcmaScript.g:1186:2: (left= bitwiseANDExpressionNoIn ( XOR right= bitwiseANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1187:3: left= bitwiseANDExpressionNoIn ( XOR right= bitwiseANDExpressionNoIn )*
			{
			DebugLocation(1187, 7);
			PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5756);
			left=bitwiseANDExpressionNoIn();
			PopFollow();

			DebugLocation(1188, 3);
			 value = left; 
			DebugLocation(1189, 3);
			// EcmaScript.g:1189:3: ( XOR right= bitwiseANDExpressionNoIn )*
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=2;
				try { DebugEnterDecision(45, false);
				int LA45_0 = input.LA(1);

				if ((LA45_0==XOR))
				{
					alt45 = 1;
				}


				} finally { DebugExitDecision(45); }
				switch ( alt45 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1190:4: XOR right= bitwiseANDExpressionNoIn
					{
					DebugLocation(1190, 4);
					Match(input,XOR,Follow._XOR_in_bitwiseXORExpressionNoIn5769); 
					DebugLocation(1190, 13);
					PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5773);
					right=bitwiseANDExpressionNoIn();
					PopFollow();

					DebugLocation(1191, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.BitwiseExclusiveOr, value, right); 

					}
					break;

				default:
					goto loop45;
				}
			}

			loop45:
				;

			} finally { DebugExitSubRule(45); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseXORExpressionNoIn", 37);
			LeaveRule("bitwiseXORExpressionNoIn", 37);
			LeaveRule_bitwiseXORExpressionNoIn();
		}
		DebugLocation(1193, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "bitwiseXORExpressionNoIn"


	partial void EnterRule_bitwiseORExpression();
	partial void LeaveRule_bitwiseORExpression();

	// $ANTLR start "bitwiseORExpression"
	// EcmaScript.g:1195:1: bitwiseORExpression returns [ExpressionSyntax value] : left= bitwiseXORExpression ( OR right= bitwiseXORExpression )* ;
	[GrammarRule("bitwiseORExpression")]
	private ExpressionSyntax bitwiseORExpression()
	{
		EnterRule_bitwiseORExpression();
		EnterRule("bitwiseORExpression", 38);
		TraceIn("bitwiseORExpression", 38);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "bitwiseORExpression");
		DebugLocation(1195, 1);
		try
		{
			// EcmaScript.g:1196:2: (left= bitwiseXORExpression ( OR right= bitwiseXORExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1197:3: left= bitwiseXORExpression ( OR right= bitwiseXORExpression )*
			{
			DebugLocation(1197, 7);
			PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression5803);
			left=bitwiseXORExpression();
			PopFollow();

			DebugLocation(1198, 3);
			 value = left; 
			DebugLocation(1199, 3);
			// EcmaScript.g:1199:3: ( OR right= bitwiseXORExpression )*
			try { DebugEnterSubRule(46);
			while (true)
			{
				int alt46=2;
				try { DebugEnterDecision(46, false);
				int LA46_0 = input.LA(1);

				if ((LA46_0==OR))
				{
					alt46 = 1;
				}


				} finally { DebugExitDecision(46); }
				switch ( alt46 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1200:4: OR right= bitwiseXORExpression
					{
					DebugLocation(1200, 4);
					Match(input,OR,Follow._OR_in_bitwiseORExpression5816); 
					DebugLocation(1200, 12);
					PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression5820);
					right=bitwiseXORExpression();
					PopFollow();

					DebugLocation(1201, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.BitwiseOr, value, right); 

					}
					break;

				default:
					goto loop46;
				}
			}

			loop46:
				;

			} finally { DebugExitSubRule(46); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseORExpression", 38);
			LeaveRule("bitwiseORExpression", 38);
			LeaveRule_bitwiseORExpression();
		}
		DebugLocation(1203, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
		return value;

	}
	// $ANTLR end "bitwiseORExpression"


	partial void EnterRule_bitwiseORExpressionNoIn();
	partial void LeaveRule_bitwiseORExpressionNoIn();

	// $ANTLR start "bitwiseORExpressionNoIn"
	// EcmaScript.g:1205:1: bitwiseORExpressionNoIn returns [ExpressionSyntax value] : left= bitwiseXORExpressionNoIn ( OR right= bitwiseXORExpressionNoIn )* ;
	[GrammarRule("bitwiseORExpressionNoIn")]
	private ExpressionSyntax bitwiseORExpressionNoIn()
	{
		EnterRule_bitwiseORExpressionNoIn();
		EnterRule("bitwiseORExpressionNoIn", 39);
		TraceIn("bitwiseORExpressionNoIn", 39);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
		DebugLocation(1205, 1);
		try
		{
			// EcmaScript.g:1206:2: (left= bitwiseXORExpressionNoIn ( OR right= bitwiseXORExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1207:3: left= bitwiseXORExpressionNoIn ( OR right= bitwiseXORExpressionNoIn )*
			{
			DebugLocation(1207, 7);
			PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5850);
			left=bitwiseXORExpressionNoIn();
			PopFollow();

			DebugLocation(1208, 3);
			 value = left; 
			DebugLocation(1209, 3);
			// EcmaScript.g:1209:3: ( OR right= bitwiseXORExpressionNoIn )*
			try { DebugEnterSubRule(47);
			while (true)
			{
				int alt47=2;
				try { DebugEnterDecision(47, false);
				int LA47_0 = input.LA(1);

				if ((LA47_0==OR))
				{
					alt47 = 1;
				}


				} finally { DebugExitDecision(47); }
				switch ( alt47 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1210:4: OR right= bitwiseXORExpressionNoIn
					{
					DebugLocation(1210, 4);
					Match(input,OR,Follow._OR_in_bitwiseORExpressionNoIn5863); 
					DebugLocation(1210, 12);
					PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5867);
					right=bitwiseXORExpressionNoIn();
					PopFollow();

					DebugLocation(1211, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.BitwiseOr, value, right); 

					}
					break;

				default:
					goto loop47;
				}
			}

			loop47:
				;

			} finally { DebugExitSubRule(47); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("bitwiseORExpressionNoIn", 39);
			LeaveRule("bitwiseORExpressionNoIn", 39);
			LeaveRule_bitwiseORExpressionNoIn();
		}
		DebugLocation(1213, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "bitwiseORExpressionNoIn"


	partial void EnterRule_logicalANDExpression();
	partial void LeaveRule_logicalANDExpression();

	// $ANTLR start "logicalANDExpression"
	// EcmaScript.g:1219:1: logicalANDExpression returns [ExpressionSyntax value] : left= bitwiseORExpression ( LAND right= bitwiseORExpression )* ;
	[GrammarRule("logicalANDExpression")]
	private ExpressionSyntax logicalANDExpression()
	{
		EnterRule_logicalANDExpression();
		EnterRule("logicalANDExpression", 40);
		TraceIn("logicalANDExpression", 40);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "logicalANDExpression");
		DebugLocation(1219, 1);
		try
		{
			// EcmaScript.g:1220:2: (left= bitwiseORExpression ( LAND right= bitwiseORExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1221:3: left= bitwiseORExpression ( LAND right= bitwiseORExpression )*
			{
			DebugLocation(1221, 7);
			PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression5901);
			left=bitwiseORExpression();
			PopFollow();

			DebugLocation(1222, 3);
			 value = left; 
			DebugLocation(1223, 3);
			// EcmaScript.g:1223:3: ( LAND right= bitwiseORExpression )*
			try { DebugEnterSubRule(48);
			while (true)
			{
				int alt48=2;
				try { DebugEnterDecision(48, false);
				int LA48_0 = input.LA(1);

				if ((LA48_0==LAND))
				{
					alt48 = 1;
				}


				} finally { DebugExitDecision(48); }
				switch ( alt48 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1224:4: LAND right= bitwiseORExpression
					{
					DebugLocation(1224, 4);
					Match(input,LAND,Follow._LAND_in_logicalANDExpression5914); 
					DebugLocation(1224, 14);
					PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression5918);
					right=bitwiseORExpression();
					PopFollow();

					DebugLocation(1225, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.And, value, right); 

					}
					break;

				default:
					goto loop48;
				}
			}

			loop48:
				;

			} finally { DebugExitSubRule(48); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logicalANDExpression", 40);
			LeaveRule("logicalANDExpression", 40);
			LeaveRule_logicalANDExpression();
		}
		DebugLocation(1227, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
		return value;

	}
	// $ANTLR end "logicalANDExpression"


	partial void EnterRule_logicalANDExpressionNoIn();
	partial void LeaveRule_logicalANDExpressionNoIn();

	// $ANTLR start "logicalANDExpressionNoIn"
	// EcmaScript.g:1229:1: logicalANDExpressionNoIn returns [ExpressionSyntax value] : left= bitwiseORExpressionNoIn ( LAND right= bitwiseORExpressionNoIn )* ;
	[GrammarRule("logicalANDExpressionNoIn")]
	private ExpressionSyntax logicalANDExpressionNoIn()
	{
		EnterRule_logicalANDExpressionNoIn();
		EnterRule("logicalANDExpressionNoIn", 41);
		TraceIn("logicalANDExpressionNoIn", 41);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
		DebugLocation(1229, 1);
		try
		{
			// EcmaScript.g:1230:2: (left= bitwiseORExpressionNoIn ( LAND right= bitwiseORExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1231:3: left= bitwiseORExpressionNoIn ( LAND right= bitwiseORExpressionNoIn )*
			{
			DebugLocation(1231, 7);
			PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5947);
			left=bitwiseORExpressionNoIn();
			PopFollow();

			DebugLocation(1232, 3);
			 value = left; 
			DebugLocation(1233, 3);
			// EcmaScript.g:1233:3: ( LAND right= bitwiseORExpressionNoIn )*
			try { DebugEnterSubRule(49);
			while (true)
			{
				int alt49=2;
				try { DebugEnterDecision(49, false);
				int LA49_0 = input.LA(1);

				if ((LA49_0==LAND))
				{
					alt49 = 1;
				}


				} finally { DebugExitDecision(49); }
				switch ( alt49 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1234:4: LAND right= bitwiseORExpressionNoIn
					{
					DebugLocation(1234, 4);
					Match(input,LAND,Follow._LAND_in_logicalANDExpressionNoIn5960); 
					DebugLocation(1234, 14);
					PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5964);
					right=bitwiseORExpressionNoIn();
					PopFollow();

					DebugLocation(1235, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.And, value, right); 

					}
					break;

				default:
					goto loop49;
				}
			}

			loop49:
				;

			} finally { DebugExitSubRule(49); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logicalANDExpressionNoIn", 41);
			LeaveRule("logicalANDExpressionNoIn", 41);
			LeaveRule_logicalANDExpressionNoIn();
		}
		DebugLocation(1237, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "logicalANDExpressionNoIn"


	partial void EnterRule_logicalORExpression();
	partial void LeaveRule_logicalORExpression();

	// $ANTLR start "logicalORExpression"
	// EcmaScript.g:1239:1: logicalORExpression returns [ExpressionSyntax value] : left= logicalANDExpression ( LOR right= logicalANDExpression )* ;
	[GrammarRule("logicalORExpression")]
	private ExpressionSyntax logicalORExpression()
	{
		EnterRule_logicalORExpression();
		EnterRule("logicalORExpression", 42);
		TraceIn("logicalORExpression", 42);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "logicalORExpression");
		DebugLocation(1239, 1);
		try
		{
			// EcmaScript.g:1240:2: (left= logicalANDExpression ( LOR right= logicalANDExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1241:3: left= logicalANDExpression ( LOR right= logicalANDExpression )*
			{
			DebugLocation(1241, 7);
			PushFollow(Follow._logicalANDExpression_in_logicalORExpression5994);
			left=logicalANDExpression();
			PopFollow();

			DebugLocation(1242, 3);
			 value = left; 
			DebugLocation(1243, 3);
			// EcmaScript.g:1243:3: ( LOR right= logicalANDExpression )*
			try { DebugEnterSubRule(50);
			while (true)
			{
				int alt50=2;
				try { DebugEnterDecision(50, false);
				int LA50_0 = input.LA(1);

				if ((LA50_0==LOR))
				{
					alt50 = 1;
				}


				} finally { DebugExitDecision(50); }
				switch ( alt50 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1244:4: LOR right= logicalANDExpression
					{
					DebugLocation(1244, 4);
					Match(input,LOR,Follow._LOR_in_logicalORExpression6007); 
					DebugLocation(1244, 13);
					PushFollow(Follow._logicalANDExpression_in_logicalORExpression6011);
					right=logicalANDExpression();
					PopFollow();

					DebugLocation(1245, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.Or, value, right); 

					}
					break;

				default:
					goto loop50;
				}
			}

			loop50:
				;

			} finally { DebugExitSubRule(50); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logicalORExpression", 42);
			LeaveRule("logicalORExpression", 42);
			LeaveRule_logicalORExpression();
		}
		DebugLocation(1247, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
		return value;

	}
	// $ANTLR end "logicalORExpression"


	partial void EnterRule_logicalORExpressionNoIn();
	partial void LeaveRule_logicalORExpressionNoIn();

	// $ANTLR start "logicalORExpressionNoIn"
	// EcmaScript.g:1249:1: logicalORExpressionNoIn returns [ExpressionSyntax value] : left= logicalANDExpressionNoIn ( LOR right= logicalANDExpressionNoIn )* ;
	[GrammarRule("logicalORExpressionNoIn")]
	private ExpressionSyntax logicalORExpressionNoIn()
	{
		EnterRule_logicalORExpressionNoIn();
		EnterRule("logicalORExpressionNoIn", 43);
		TraceIn("logicalORExpressionNoIn", 43);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax left = default(ExpressionSyntax);
		ExpressionSyntax right = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
		DebugLocation(1249, 1);
		try
		{
			// EcmaScript.g:1250:2: (left= logicalANDExpressionNoIn ( LOR right= logicalANDExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1251:3: left= logicalANDExpressionNoIn ( LOR right= logicalANDExpressionNoIn )*
			{
			DebugLocation(1251, 7);
			PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn6041);
			left=logicalANDExpressionNoIn();
			PopFollow();

			DebugLocation(1252, 3);
			 value = left; 
			DebugLocation(1253, 3);
			// EcmaScript.g:1253:3: ( LOR right= logicalANDExpressionNoIn )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_0 = input.LA(1);

				if ((LA51_0==LOR))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1254:4: LOR right= logicalANDExpressionNoIn
					{
					DebugLocation(1254, 4);
					Match(input,LOR,Follow._LOR_in_logicalORExpressionNoIn6054); 
					DebugLocation(1254, 13);
					PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn6058);
					right=logicalANDExpressionNoIn();
					PopFollow();

					DebugLocation(1255, 4);
					 value = _builder.BuildBinary(SyntaxExpressionType.Or, value, right); 

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("logicalORExpressionNoIn", 43);
			LeaveRule("logicalORExpressionNoIn", 43);
			LeaveRule_logicalORExpressionNoIn();
		}
		DebugLocation(1257, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "logicalORExpressionNoIn"


	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();

	// $ANTLR start "conditionalExpression"
	// EcmaScript.g:1263:1: conditionalExpression returns [ExpressionSyntax value] : expr1= logicalORExpression ( QUE expr2= assignmentExpression COLON expr3= assignmentExpression )? ;
	[GrammarRule("conditionalExpression")]
	private ExpressionSyntax conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 44);
		TraceIn("conditionalExpression", 44);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax expr1 = default(ExpressionSyntax);
		ExpressionSyntax expr2 = default(ExpressionSyntax);
		ExpressionSyntax expr3 = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(1263, 1);
		try
		{
			// EcmaScript.g:1264:2: (expr1= logicalORExpression ( QUE expr2= assignmentExpression COLON expr3= assignmentExpression )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1265:3: expr1= logicalORExpression ( QUE expr2= assignmentExpression COLON expr3= assignmentExpression )?
			{
			DebugLocation(1265, 8);
			PushFollow(Follow._logicalORExpression_in_conditionalExpression6092);
			expr1=logicalORExpression();
			PopFollow();

			DebugLocation(1266, 3);
			 value = expr1; 
			DebugLocation(1267, 3);
			// EcmaScript.g:1267:3: ( QUE expr2= assignmentExpression COLON expr3= assignmentExpression )?
			int alt52=2;
			try { DebugEnterSubRule(52);
			try { DebugEnterDecision(52, false);
			int LA52_0 = input.LA(1);

			if ((LA52_0==QUE))
			{
				alt52 = 1;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1268:4: QUE expr2= assignmentExpression COLON expr3= assignmentExpression
				{
				DebugLocation(1268, 4);
				Match(input,QUE,Follow._QUE_in_conditionalExpression6105); 
				DebugLocation(1268, 13);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression6109);
				expr2=assignmentExpression();
				PopFollow();

				DebugLocation(1269, 4);
				Match(input,COLON,Follow._COLON_in_conditionalExpression6114); 
				DebugLocation(1269, 15);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression6118);
				expr3=assignmentExpression();
				PopFollow();

				DebugLocation(1270, 4);
				 value = _builder.BuildTernary(expr1, expr2, expr3); 

				}
				break;

			}
			} finally { DebugExitSubRule(52); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("conditionalExpression", 44);
			LeaveRule("conditionalExpression", 44);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(1272, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return value;

	}
	// $ANTLR end "conditionalExpression"


	partial void EnterRule_conditionalExpressionNoIn();
	partial void LeaveRule_conditionalExpressionNoIn();

	// $ANTLR start "conditionalExpressionNoIn"
	// EcmaScript.g:1274:1: conditionalExpressionNoIn returns [ExpressionSyntax value] : expr1= logicalORExpressionNoIn ( QUE expr2= assignmentExpressionNoIn COLON expr3= assignmentExpressionNoIn )? ;
	[GrammarRule("conditionalExpressionNoIn")]
	private ExpressionSyntax conditionalExpressionNoIn()
	{
		EnterRule_conditionalExpressionNoIn();
		EnterRule("conditionalExpressionNoIn", 45);
		TraceIn("conditionalExpressionNoIn", 45);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax expr1 = default(ExpressionSyntax);
		ExpressionSyntax expr2 = default(ExpressionSyntax);
		ExpressionSyntax expr3 = default(ExpressionSyntax);

		try { DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
		DebugLocation(1274, 1);
		try
		{
			// EcmaScript.g:1275:2: (expr1= logicalORExpressionNoIn ( QUE expr2= assignmentExpressionNoIn COLON expr3= assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1276:3: expr1= logicalORExpressionNoIn ( QUE expr2= assignmentExpressionNoIn COLON expr3= assignmentExpressionNoIn )?
			{
			DebugLocation(1276, 8);
			PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn6147);
			expr1=logicalORExpressionNoIn();
			PopFollow();

			DebugLocation(1277, 3);
			 value = expr1; 
			DebugLocation(1278, 3);
			// EcmaScript.g:1278:3: ( QUE expr2= assignmentExpressionNoIn COLON expr3= assignmentExpressionNoIn )?
			int alt53=2;
			try { DebugEnterSubRule(53);
			try { DebugEnterDecision(53, false);
			int LA53_0 = input.LA(1);

			if ((LA53_0==QUE))
			{
				alt53 = 1;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1279:4: QUE expr2= assignmentExpressionNoIn COLON expr3= assignmentExpressionNoIn
				{
				DebugLocation(1279, 4);
				Match(input,QUE,Follow._QUE_in_conditionalExpressionNoIn6160); 
				DebugLocation(1279, 13);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn6164);
				expr2=assignmentExpressionNoIn();
				PopFollow();

				DebugLocation(1280, 4);
				Match(input,COLON,Follow._COLON_in_conditionalExpressionNoIn6169); 
				DebugLocation(1280, 15);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn6173);
				expr3=assignmentExpressionNoIn();
				PopFollow();

				DebugLocation(1281, 4);
				 value = _builder.BuildTernary(expr1, expr2, expr3); 

				}
				break;

			}
			} finally { DebugExitSubRule(53); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("conditionalExpressionNoIn", 45);
			LeaveRule("conditionalExpressionNoIn", 45);
			LeaveRule_conditionalExpressionNoIn();
		}
		DebugLocation(1283, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "conditionalExpressionNoIn"


	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();

	// $ANTLR start "assignmentExpression"
	// EcmaScript.g:1315:1: assignmentExpression returns [ExpressionSyntax value] : lhs= conditionalExpression ({...}?ass= assignmentOperator exp= assignmentExpression )? ;
	[GrammarRule("assignmentExpression")]
	private ExpressionSyntax assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 46);
		TraceIn("assignmentExpression", 46);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax lhs = default(ExpressionSyntax);
		EcmaScriptParser.assignmentOperator_return ass = default(EcmaScriptParser.assignmentOperator_return);
		ExpressionSyntax exp = default(ExpressionSyntax);


		    bool isLhs;

		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(1315, 1);
		try
		{
			// EcmaScript.g:1319:2: (lhs= conditionalExpression ({...}?ass= assignmentOperator exp= assignmentExpression )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1320:9: lhs= conditionalExpression ({...}?ass= assignmentOperator exp= assignmentExpression )?
			{
			DebugLocation(1320, 12);
			PushFollow(Follow._conditionalExpression_in_assignmentExpression6220);
			lhs=conditionalExpression();
			PopFollow();

			DebugLocation(1321, 9);
			 value = lhs; isLhs = IsLeftHandSideAssign(lhs); 
			DebugLocation(1322, 6);
			// EcmaScript.g:1322:6: ({...}?ass= assignmentOperator exp= assignmentExpression )?
			int alt54=2;
			try { DebugEnterSubRule(54);
			try { DebugEnterDecision(54, false);
			int LA54_0 = input.LA(1);

			if ((LA54_0==ADDASS||LA54_0==ANDASS||LA54_0==ASSIGN||LA54_0==DIVASS||LA54_0==MODASS||LA54_0==MULASS||LA54_0==ORASS||LA54_0==SHLASS||LA54_0==SHRASS||LA54_0==SHUASS||LA54_0==SUBASS||LA54_0==XORASS))
			{
				int LA54_1 = input.LA(2);

				if ((( isLhs )))
				{
					alt54 = 1;
				}
			}
			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1323:13: {...}?ass= assignmentOperator exp= assignmentExpression
				{
				DebugLocation(1323, 13);
				if (!(( isLhs )))
				{
					throw new FailedPredicateException(input, "assignmentExpression", " isLhs ");
				}
				DebugLocation(1324, 16);
				PushFollow(Follow._assignmentOperator_in_assignmentExpression6267);
				ass=assignmentOperator();
				PopFollow();

				DebugLocation(1325, 16);
				PushFollow(Follow._assignmentExpression_in_assignmentExpression6283);
				exp=assignmentExpression();
				PopFollow();

				DebugLocation(1326, 13);

				                value = _builder.BuildAssignment(
				                    ResolveAssignmentOperator((ass!=null?input.ToString(ass.Start,ass.Stop):null)),
				                    value,
				                    exp
				                );
				            

				}
				break;

			}
			} finally { DebugExitSubRule(54); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignmentExpression", 46);
			LeaveRule("assignmentExpression", 46);
			LeaveRule_assignmentExpression();
		}
		DebugLocation(1334, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return value;

	}
	// $ANTLR end "assignmentExpression"

	private sealed partial class assignmentOperator_return : ParserRuleReturnScope<IToken>
	{
		public assignmentOperator_return(EcmaScriptParser grammar) {OnCreated(grammar);}
		partial void OnCreated(EcmaScriptParser grammar);
	}

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();

	// $ANTLR start "assignmentOperator"
	// EcmaScript.g:1336:1: assignmentOperator : ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS );
	[GrammarRule("assignmentOperator")]
	private EcmaScriptParser.assignmentOperator_return assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 47);
		TraceIn("assignmentOperator", 47);
		EcmaScriptParser.assignmentOperator_return retval = new EcmaScriptParser.assignmentOperator_return(this);
		retval.Start = (IToken)input.LT(1);

		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(1336, 1);
		try
		{
			// EcmaScript.g:1337:2: ( ASSIGN | MULASS | DIVASS | MODASS | ADDASS | SUBASS | SHLASS | SHRASS | SHUASS | ANDASS | XORASS | ORASS )
			DebugEnterAlt(1);
			// EcmaScript.g:
			{
			DebugLocation(1337, 2);
			if (input.LA(1)==ADDASS||input.LA(1)==ANDASS||input.LA(1)==ASSIGN||input.LA(1)==DIVASS||input.LA(1)==MODASS||input.LA(1)==MULASS||input.LA(1)==ORASS||input.LA(1)==SHLASS||input.LA(1)==SHRASS||input.LA(1)==SHUASS||input.LA(1)==SUBASS||input.LA(1)==XORASS)
			{
				input.Consume();
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignmentOperator", 47);
			LeaveRule("assignmentOperator", 47);
			LeaveRule_assignmentOperator();
		}
		DebugLocation(1349, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"


	partial void EnterRule_assignmentExpressionNoIn();
	partial void LeaveRule_assignmentExpressionNoIn();

	// $ANTLR start "assignmentExpressionNoIn"
	// EcmaScript.g:1351:1: assignmentExpressionNoIn returns [ExpressionSyntax value] : lhs= conditionalExpressionNoIn ({...}?ass= assignmentOperator exp= assignmentExpressionNoIn )? ;
	[GrammarRule("assignmentExpressionNoIn")]
	private ExpressionSyntax assignmentExpressionNoIn()
	{
		EnterRule_assignmentExpressionNoIn();
		EnterRule("assignmentExpressionNoIn", 48);
		TraceIn("assignmentExpressionNoIn", 48);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax lhs = default(ExpressionSyntax);
		EcmaScriptParser.assignmentOperator_return ass = default(EcmaScriptParser.assignmentOperator_return);
		ExpressionSyntax exp = default(ExpressionSyntax);


			bool isLhs;

		try { DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
		DebugLocation(1351, 1);
		try
		{
			// EcmaScript.g:1356:2: (lhs= conditionalExpressionNoIn ({...}?ass= assignmentOperator exp= assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1357:9: lhs= conditionalExpressionNoIn ({...}?ass= assignmentOperator exp= assignmentExpressionNoIn )?
			{
			DebugLocation(1357, 12);
			PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn6406);
			lhs=conditionalExpressionNoIn();
			PopFollow();

			DebugLocation(1358, 9);
			 value = lhs; isLhs = IsLeftHandSideAssign(lhs); 
			DebugLocation(1359, 6);
			// EcmaScript.g:1359:6: ({...}?ass= assignmentOperator exp= assignmentExpressionNoIn )?
			int alt55=2;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			int LA55_0 = input.LA(1);

			if ((LA55_0==ADDASS||LA55_0==ANDASS||LA55_0==ASSIGN||LA55_0==DIVASS||LA55_0==MODASS||LA55_0==MULASS||LA55_0==ORASS||LA55_0==SHLASS||LA55_0==SHRASS||LA55_0==SHUASS||LA55_0==SUBASS||LA55_0==XORASS))
			{
				int LA55_1 = input.LA(2);

				if ((( isLhs )))
				{
					alt55 = 1;
				}
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1360:13: {...}?ass= assignmentOperator exp= assignmentExpressionNoIn
				{
				DebugLocation(1360, 13);
				if (!(( isLhs )))
				{
					throw new FailedPredicateException(input, "assignmentExpressionNoIn", " isLhs ");
				}
				DebugLocation(1361, 16);
				PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn6454);
				ass=assignmentOperator();
				PopFollow();

				DebugLocation(1362, 16);
				PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn6470);
				exp=assignmentExpressionNoIn();
				PopFollow();

				DebugLocation(1363, 13);

				                value = _builder.BuildAssignment(
				                    ResolveAssignmentOperator((ass!=null?input.ToString(ass.Start,ass.Stop):null)),
				                    value,
				                    exp
				                );
				            

				}
				break;

			}
			} finally { DebugExitSubRule(55); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assignmentExpressionNoIn", 48);
			LeaveRule("assignmentExpressionNoIn", 48);
			LeaveRule_assignmentExpressionNoIn();
		}
		DebugLocation(1371, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
		return value;

	}
	// $ANTLR end "assignmentExpressionNoIn"


	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// EcmaScript.g:1377:1: expression returns [ExpressionSyntax value] : first= assignmentExpression ( COMMA follow= assignmentExpression )* ;
	[GrammarRule("expression")]
	private ExpressionSyntax expression()
	{
		EnterRule_expression();
		EnterRule("expression", 49);
		TraceIn("expression", 49);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax first = default(ExpressionSyntax);
		ExpressionSyntax follow = default(ExpressionSyntax);


			ReadOnlyArray<ExpressionSyntax>.Builder nodes = null;

		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(1377, 1);
		try
		{
			// EcmaScript.g:1385:2: (first= assignmentExpression ( COMMA follow= assignmentExpression )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1386:9: first= assignmentExpression ( COMMA follow= assignmentExpression )*
			{
			DebugLocation(1386, 14);
			PushFollow(Follow._assignmentExpression_in_expression6536);
			first=assignmentExpression();
			PopFollow();

			DebugLocation(1387, 9);
			 value = first; 
			DebugLocation(1388, 9);
			// EcmaScript.g:1388:9: ( COMMA follow= assignmentExpression )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_0 = input.LA(1);

				if ((LA56_0==COMMA))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1389:13: COMMA follow= assignmentExpression
					{
					DebugLocation(1389, 13);
					Match(input,COMMA,Follow._COMMA_in_expression6570); 
					DebugLocation(1390, 19);
					PushFollow(Follow._assignmentExpression_in_expression6586);
					follow=assignmentExpression();
					PopFollow();

					DebugLocation(1391, 13);

					                if (nodes == null)
									{
					                    nodes = new ReadOnlyArray<ExpressionSyntax>.Builder();
										nodes.Add(value);
									}

					                nodes.Add(follow);
					            

					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }


			}


			    if (nodes != null)
			        value = _builder.BuildCommaOperator(nodes.ToReadOnly());

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expression", 49);
			LeaveRule("expression", 49);
			LeaveRule_expression();
		}
		DebugLocation(1401, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return value;

	}
	// $ANTLR end "expression"


	partial void EnterRule_expressionNoIn();
	partial void LeaveRule_expressionNoIn();

	// $ANTLR start "expressionNoIn"
	// EcmaScript.g:1403:1: expressionNoIn returns [ExpressionSyntax value] : first= assignmentExpressionNoIn ( COMMA follow= assignmentExpressionNoIn )* ;
	[GrammarRule("expressionNoIn")]
	private ExpressionSyntax expressionNoIn()
	{
		EnterRule_expressionNoIn();
		EnterRule("expressionNoIn", 50);
		TraceIn("expressionNoIn", 50);
		ExpressionSyntax value = default(ExpressionSyntax);

		ExpressionSyntax first = default(ExpressionSyntax);
		ExpressionSyntax follow = default(ExpressionSyntax);


			ReadOnlyArray<ExpressionSyntax>.Builder nodes = null;

		try { DebugEnterRule(GrammarFileName, "expressionNoIn");
		DebugLocation(1403, 1);
		try
		{
			// EcmaScript.g:1411:2: (first= assignmentExpressionNoIn ( COMMA follow= assignmentExpressionNoIn )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1412:9: first= assignmentExpressionNoIn ( COMMA follow= assignmentExpressionNoIn )*
			{
			DebugLocation(1412, 14);
			PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn6646);
			first=assignmentExpressionNoIn();
			PopFollow();

			DebugLocation(1413, 9);
			 value = first; 
			DebugLocation(1414, 9);
			// EcmaScript.g:1414:9: ( COMMA follow= assignmentExpressionNoIn )*
			try { DebugEnterSubRule(57);
			while (true)
			{
				int alt57=2;
				try { DebugEnterDecision(57, false);
				int LA57_0 = input.LA(1);

				if ((LA57_0==COMMA))
				{
					alt57 = 1;
				}


				} finally { DebugExitDecision(57); }
				switch ( alt57 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1415:13: COMMA follow= assignmentExpressionNoIn
					{
					DebugLocation(1415, 13);
					Match(input,COMMA,Follow._COMMA_in_expressionNoIn6680); 
					DebugLocation(1416, 19);
					PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn6696);
					follow=assignmentExpressionNoIn();
					PopFollow();

					DebugLocation(1417, 13);

					                if (nodes == null)
									{
					                    nodes = new ReadOnlyArray<ExpressionSyntax>.Builder();
										nodes.Add(value);
									}

					                nodes.Add(follow);
					            

					}
					break;

				default:
					goto loop57;
				}
			}

			loop57:
				;

			} finally { DebugExitSubRule(57); }


			}


			    if (nodes != null)
			        value = _builder.BuildCommaOperator(nodes.ToReadOnly());

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionNoIn", 50);
			LeaveRule("expressionNoIn", 50);
			LeaveRule_expressionNoIn();
		}
		DebugLocation(1427, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
		return value;

	}
	// $ANTLR end "expressionNoIn"


	partial void EnterRule_semic();
	partial void LeaveRule_semic();

	// $ANTLR start "semic"
	// EcmaScript.g:1455:1: semic : ( SEMIC | EOF | RBRACE | EOL | MultiLineComment );
	[GrammarRule("semic")]
	private void semic()
	{
		EnterRule_semic();
		EnterRule("semic", 51);
		TraceIn("semic", 51);

			// Mark current position so we can unconsume a RBRACE.
			int marker = input.Mark();
			// Promote EOL if appropriate
			PromoteEol();

		try { DebugEnterRule(GrammarFileName, "semic");
		DebugLocation(1455, 1);
		try
		{
			// EcmaScript.g:1463:2: ( SEMIC | EOF | RBRACE | EOL | MultiLineComment )
			int alt58=5;
			try { DebugEnterDecision(58, false);
			switch (input.LA(1))
			{
			case SEMIC:
				{
				alt58 = 1;
				}
				break;
			case EOF:
				{
				alt58 = 2;
				}
				break;
			case RBRACE:
				{
				alt58 = 3;
				}
				break;
			case EOL:
				{
				alt58 = 4;
				}
				break;
			case MultiLineComment:
				{
				alt58 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 58, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1463:4: SEMIC
				{
				DebugLocation(1463, 4);
				Match(input,SEMIC,Follow._SEMIC_in_semic6749); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1464:4: EOF
				{
				DebugLocation(1464, 4);
				Match(input,EOF,Follow._EOF_in_semic6754); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:1465:4: RBRACE
				{
				DebugLocation(1465, 4);
				Match(input,RBRACE,Follow._RBRACE_in_semic6759); 
				DebugLocation(1465, 11);
				 input.Rewind(marker); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:1466:4: EOL
				{
				DebugLocation(1466, 4);
				Match(input,EOL,Follow._EOL_in_semic6766); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// EcmaScript.g:1467:7: MultiLineComment
				{
				DebugLocation(1467, 7);
				Match(input,MultiLineComment,Follow._MultiLineComment_in_semic6774); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("semic", 51);
			LeaveRule("semic", 51);
			LeaveRule_semic();
		}
		DebugLocation(1468, 1);
		} finally { DebugExitRule(GrammarFileName, "semic"); }
		return;

	}
	// $ANTLR end "semic"


	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// EcmaScript.g:1478:1: statement returns [SyntaxNode value] options {k=1; } : ({...}?b= block |{...}?func= functionDeclaration |st= statementTail );
	[GrammarRule("statement")]
	private SyntaxNode statement()
	{
		EnterRule_statement();
		EnterRule("statement", 52);
		TraceIn("statement", 52);
		SyntaxNode value = default(SyntaxNode);

		BlockSyntax b = default(BlockSyntax);
		SyntaxNode func = default(SyntaxNode);
		SyntaxNode st = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(1478, 1);
		try
		{
			// EcmaScript.g:1484:2: ({...}?b= block |{...}?func= functionDeclaration |st= statementTail )
			int alt59=3;
			try { DebugEnterDecision(59, false);
			try
			{
				alt59 = dfa59.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1484:4: {...}?b= block
				{
				DebugLocation(1484, 4);
				if (!(( input.LA(1) == LBRACE )))
				{
					throw new FailedPredicateException(input, "statement", " input.LA(1) == LBRACE ");
				}
				DebugLocation(1484, 32);
				PushFollow(Follow._block_in_statement6810);
				b=block();
				PopFollow();

				DebugLocation(1484, 39);
				 value = b; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1485:4: {...}?func= functionDeclaration
				{
				DebugLocation(1485, 4);
				if (!(( input.LA(1) == FUNCTION )))
				{
					throw new FailedPredicateException(input, "statement", " input.LA(1) == FUNCTION ");
				}
				DebugLocation(1485, 37);
				PushFollow(Follow._functionDeclaration_in_statement6821);
				func=functionDeclaration();
				PopFollow();

				DebugLocation(1485, 58);
				 value = func; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:1486:4: st= statementTail
				{
				DebugLocation(1486, 6);
				PushFollow(Follow._statementTail_in_statement6830);
				st=statementTail();
				PopFollow();

				DebugLocation(1486, 21);
				 value = st; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statement", 52);
			LeaveRule("statement", 52);
			LeaveRule_statement();
		}
		DebugLocation(1487, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return value;

	}
	// $ANTLR end "statement"


	partial void EnterRule_statementTail();
	partial void LeaveRule_statementTail();

	// $ANTLR start "statementTail"
	// EcmaScript.g:1489:1: statementTail returns [SyntaxNode value] : (vst= variableStatement |est= emptyStatement |exst= expressionStatement |ifst= ifStatement |itst= iterationStatement |cost= continueStatement |brst= breakStatement |rst= returnStatement |wist= withStatement |last= labelledStatement |swst= switchStatement |thst= throwStatement |trst= tryStatement );
	[GrammarRule("statementTail")]
	private SyntaxNode statementTail()
	{
		EnterRule_statementTail();
		EnterRule("statementTail", 53);
		TraceIn("statementTail", 53);
		SyntaxNode value = default(SyntaxNode);

		SyntaxNode vst = default(SyntaxNode);
		SyntaxNode est = default(SyntaxNode);
		SyntaxNode exst = default(SyntaxNode);
		SyntaxNode ifst = default(SyntaxNode);
		SyntaxNode itst = default(SyntaxNode);
		SyntaxNode cost = default(SyntaxNode);
		SyntaxNode brst = default(SyntaxNode);
		ReturnSyntax rst = default(ReturnSyntax);
		SyntaxNode wist = default(SyntaxNode);
		SyntaxNode last = default(SyntaxNode);
		SyntaxNode swst = default(SyntaxNode);
		SyntaxNode thst = default(SyntaxNode);
		TrySyntax trst = default(TrySyntax);

		try { DebugEnterRule(GrammarFileName, "statementTail");
		DebugLocation(1489, 1);
		try
		{
			// EcmaScript.g:1490:2: (vst= variableStatement |est= emptyStatement |exst= expressionStatement |ifst= ifStatement |itst= iterationStatement |cost= continueStatement |brst= breakStatement |rst= returnStatement |wist= withStatement |last= labelledStatement |swst= switchStatement |thst= throwStatement |trst= tryStatement )
			int alt60=13;
			try { DebugEnterDecision(60, false);
			try
			{
				alt60 = dfa60.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1490:4: vst= variableStatement
				{
				DebugLocation(1490, 7);
				PushFollow(Follow._variableStatement_in_statementTail6851);
				vst=variableStatement();
				PopFollow();

				DebugLocation(1490, 26);
				 value = vst; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1491:4: est= emptyStatement
				{
				DebugLocation(1491, 7);
				PushFollow(Follow._emptyStatement_in_statementTail6860);
				est=emptyStatement();
				PopFollow();

				DebugLocation(1491, 23);
				 value = est; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:1492:4: exst= expressionStatement
				{
				DebugLocation(1492, 8);
				PushFollow(Follow._expressionStatement_in_statementTail6869);
				exst=expressionStatement();
				PopFollow();

				DebugLocation(1492, 29);
				 value = exst; 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// EcmaScript.g:1493:4: ifst= ifStatement
				{
				DebugLocation(1493, 8);
				PushFollow(Follow._ifStatement_in_statementTail6878);
				ifst=ifStatement();
				PopFollow();

				DebugLocation(1493, 21);
				 value = ifst; 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// EcmaScript.g:1494:4: itst= iterationStatement
				{
				DebugLocation(1494, 8);
				PushFollow(Follow._iterationStatement_in_statementTail6887);
				itst=iterationStatement();
				PopFollow();

				DebugLocation(1494, 28);
				 value = itst; 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// EcmaScript.g:1495:4: cost= continueStatement
				{
				DebugLocation(1495, 8);
				PushFollow(Follow._continueStatement_in_statementTail6896);
				cost=continueStatement();
				PopFollow();

				DebugLocation(1495, 27);
				 value = cost; 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// EcmaScript.g:1496:4: brst= breakStatement
				{
				DebugLocation(1496, 8);
				PushFollow(Follow._breakStatement_in_statementTail6905);
				brst=breakStatement();
				PopFollow();

				DebugLocation(1496, 24);
				 value = brst; 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// EcmaScript.g:1497:4: rst= returnStatement
				{
				DebugLocation(1497, 7);
				PushFollow(Follow._returnStatement_in_statementTail6914);
				rst=returnStatement();
				PopFollow();

				DebugLocation(1497, 24);
				 value = rst; 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// EcmaScript.g:1498:4: wist= withStatement
				{
				DebugLocation(1498, 8);
				PushFollow(Follow._withStatement_in_statementTail6923);
				wist=withStatement();
				PopFollow();

				DebugLocation(1498, 23);
				 value = wist; 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// EcmaScript.g:1499:4: last= labelledStatement
				{
				DebugLocation(1499, 8);
				PushFollow(Follow._labelledStatement_in_statementTail6932);
				last=labelledStatement();
				PopFollow();

				DebugLocation(1499, 27);
				 value = last; 

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// EcmaScript.g:1500:4: swst= switchStatement
				{
				DebugLocation(1500, 8);
				PushFollow(Follow._switchStatement_in_statementTail6941);
				swst=switchStatement();
				PopFollow();

				DebugLocation(1500, 25);
				 value = swst; 

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// EcmaScript.g:1501:4: thst= throwStatement
				{
				DebugLocation(1501, 8);
				PushFollow(Follow._throwStatement_in_statementTail6950);
				thst=throwStatement();
				PopFollow();

				DebugLocation(1501, 24);
				 value = thst; 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// EcmaScript.g:1502:4: trst= tryStatement
				{
				DebugLocation(1502, 8);
				PushFollow(Follow._tryStatement_in_statementTail6959);
				trst=tryStatement();
				PopFollow();

				DebugLocation(1502, 22);
				 value = trst; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("statementTail", 53);
			LeaveRule("statementTail", 53);
			LeaveRule_statementTail();
		}
		DebugLocation(1503, 1);
		} finally { DebugExitRule(GrammarFileName, "statementTail"); }
		return value;

	}
	// $ANTLR end "statementTail"


	partial void EnterRule_block();
	partial void LeaveRule_block();

	// $ANTLR start "block"
	// EcmaScript.g:1507:1: block returns [BlockSyntax value] : lb= LBRACE (st= statement )* RBRACE ;
	[GrammarRule("block")]
	private BlockSyntax block()
	{
		EnterRule_block();
		EnterRule("block", 54);
		TraceIn("block", 54);
		BlockSyntax value = default(BlockSyntax);

		IToken lb = default(IToken);
		SyntaxNode st = default(SyntaxNode);


		    var statements = new ReadOnlyArray<SyntaxNode>.Builder();

		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(1507, 1);
		try
		{
			// EcmaScript.g:1514:2: (lb= LBRACE (st= statement )* RBRACE )
			DebugEnterAlt(1);
			// EcmaScript.g:1515:9: lb= LBRACE (st= statement )* RBRACE
			{
			DebugLocation(1515, 11);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_block6998); 
			DebugLocation(1516, 9);
			// EcmaScript.g:1516:9: (st= statement )*
			try { DebugEnterSubRule(61);
			while (true)
			{
				int alt61=2;
				try { DebugEnterDecision(61, false);
				int LA61_0 = input.LA(1);

				if ((LA61_0==ADD||LA61_0==BREAK||LA61_0==CONTINUE||LA61_0==DEC||LA61_0==DELETE||LA61_0==DO||LA61_0==DecimalLiteral||LA61_0==FALSE||LA61_0==FOR||LA61_0==FUNCTION||(LA61_0>=HexIntegerLiteral && LA61_0<=IF)||LA61_0==INC||LA61_0==INV||LA61_0==Identifier||(LA61_0>=LBRACE && LA61_0<=LBRACK)||LA61_0==LPAREN||(LA61_0>=NEW && LA61_0<=NOT)||LA61_0==NULL||LA61_0==OctalIntegerLiteral||LA61_0==RETURN||LA61_0==RegularExpressionLiteral||LA61_0==SEMIC||LA61_0==SUB||LA61_0==SWITCH||LA61_0==StringLiteral||(LA61_0>=THIS && LA61_0<=THROW)||(LA61_0>=TRUE && LA61_0<=TYPEOF)||(LA61_0>=VAR && LA61_0<=VOID)||(LA61_0>=WHILE && LA61_0<=WITH)))
				{
					alt61 = 1;
				}


				} finally { DebugExitDecision(61); }
				switch ( alt61 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1517:13: st= statement
					{
					DebugLocation(1517, 15);
					PushFollow(Follow._statement_in_block7024);
					st=statement();
					PopFollow();

					DebugLocation(1518, 13);
					 statements.Add(st); 

					}
					break;

				default:
					goto loop61;
				}
			}

			loop61:
				;

			} finally { DebugExitSubRule(61); }

			DebugLocation(1520, 9);
			Match(input,RBRACE,Follow._RBRACE_in_block7059); 

			}


			    value = _builder.BuildBlock(statements.ToReadOnly());

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("block", 54);
			LeaveRule("block", 54);
			LeaveRule_block();
		}
		DebugLocation(1521, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return value;

	}
	// $ANTLR end "block"


	partial void EnterRule_blockStatements();
	partial void LeaveRule_blockStatements();

	// $ANTLR start "blockStatements"
	// EcmaScript.g:1525:1: blockStatements : (st= statement )* ;
	[GrammarRule("blockStatements")]
	private void blockStatements()
	{
		EnterRule_blockStatements();
		EnterRule("blockStatements", 55);
		TraceIn("blockStatements", 55);
		SyntaxNode st = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "blockStatements");
		DebugLocation(1525, 1);
		try
		{
			// EcmaScript.g:1526:2: ( (st= statement )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1527:9: (st= statement )*
			{
			DebugLocation(1527, 9);
			// EcmaScript.g:1527:9: (st= statement )*
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_0 = input.LA(1);

				if ((LA62_0==ADD||LA62_0==BREAK||LA62_0==CONTINUE||LA62_0==DEC||LA62_0==DELETE||LA62_0==DO||LA62_0==DecimalLiteral||LA62_0==FALSE||LA62_0==FOR||LA62_0==FUNCTION||(LA62_0>=HexIntegerLiteral && LA62_0<=IF)||LA62_0==INC||LA62_0==INV||LA62_0==Identifier||(LA62_0>=LBRACE && LA62_0<=LBRACK)||LA62_0==LPAREN||(LA62_0>=NEW && LA62_0<=NOT)||LA62_0==NULL||LA62_0==OctalIntegerLiteral||LA62_0==RETURN||LA62_0==RegularExpressionLiteral||LA62_0==SEMIC||LA62_0==SUB||LA62_0==SWITCH||LA62_0==StringLiteral||(LA62_0>=THIS && LA62_0<=THROW)||(LA62_0>=TRUE && LA62_0<=TYPEOF)||(LA62_0>=VAR && LA62_0<=VOID)||(LA62_0>=WHILE && LA62_0<=WITH)))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch ( alt62 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1528:13: st= statement
					{
					DebugLocation(1528, 15);
					PushFollow(Follow._statement_in_blockStatements7096);
					st=statement();
					PopFollow();

					DebugLocation(1529, 13);
					 _builder.AddStatement(st); 

					}
					break;

				default:
					goto loop62;
				}
			}

			loop62:
				;

			} finally { DebugExitSubRule(62); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("blockStatements", 55);
			LeaveRule("blockStatements", 55);
			LeaveRule_blockStatements();
		}
		DebugLocation(1531, 1);
		} finally { DebugExitRule(GrammarFileName, "blockStatements"); }
		return;

	}
	// $ANTLR end "blockStatements"


	partial void EnterRule_variableStatement();
	partial void LeaveRule_variableStatement();

	// $ANTLR start "variableStatement"
	// EcmaScript.g:1538:1: variableStatement returns [SyntaxNode value] : VAR first= variableDeclaration ( COMMA follow= variableDeclaration )* semic ;
	[GrammarRule("variableStatement")]
	private SyntaxNode variableStatement()
	{
		EnterRule_variableStatement();
		EnterRule("variableStatement", 56);
		TraceIn("variableStatement", 56);
		SyntaxNode value = default(SyntaxNode);

		VariableDeclaration first = default(VariableDeclaration);
		VariableDeclaration follow = default(VariableDeclaration);


		    var declarations = new ReadOnlyArray<VariableDeclaration>.Builder();
		    var start = input.LT(1);

		try { DebugEnterRule(GrammarFileName, "variableStatement");
		DebugLocation(1538, 1);
		try
		{
			// EcmaScript.g:1546:2: ( VAR first= variableDeclaration ( COMMA follow= variableDeclaration )* semic )
			DebugEnterAlt(1);
			// EcmaScript.g:1547:9: VAR first= variableDeclaration ( COMMA follow= variableDeclaration )* semic
			{
			DebugLocation(1547, 9);
			Match(input,VAR,Follow._VAR_in_variableStatement7160); 
			DebugLocation(1547, 18);
			PushFollow(Follow._variableDeclaration_in_variableStatement7164);
			first=variableDeclaration();
			PopFollow();

			DebugLocation(1548, 9);
			 declarations.Add(first); 
			DebugLocation(1549, 9);
			// EcmaScript.g:1549:9: ( COMMA follow= variableDeclaration )*
			try { DebugEnterSubRule(63);
			while (true)
			{
				int alt63=2;
				try { DebugEnterDecision(63, false);
				int LA63_0 = input.LA(1);

				if ((LA63_0==COMMA))
				{
					alt63 = 1;
				}


				} finally { DebugExitDecision(63); }
				switch ( alt63 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1550:13: COMMA follow= variableDeclaration
					{
					DebugLocation(1550, 13);
					Match(input,COMMA,Follow._COMMA_in_variableStatement7198); 
					DebugLocation(1550, 25);
					PushFollow(Follow._variableDeclaration_in_variableStatement7202);
					follow=variableDeclaration();
					PopFollow();

					DebugLocation(1551, 13);
					 declarations.Add(follow); 

					}
					break;

				default:
					goto loop63;
				}
			}

			loop63:
				;

			} finally { DebugExitSubRule(63); }

			DebugLocation(1553, 9);
			PushFollow(Follow._semic_in_variableStatement7237);
			semic();
			PopFollow();


			}


			    value = _builder.BuildVariableDeclaration(declarations.ToReadOnly(), GetLocation(start, input.LT(-1)));

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variableStatement", 56);
			LeaveRule("variableStatement", 56);
			LeaveRule_variableStatement();
		}
		DebugLocation(1554, 1);
		} finally { DebugExitRule(GrammarFileName, "variableStatement"); }
		return value;

	}
	// $ANTLR end "variableStatement"


	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();

	// $ANTLR start "variableDeclaration"
	// EcmaScript.g:1556:1: variableDeclaration returns [VariableDeclaration value] : id= Identifier ( ASSIGN ass= assignmentExpression )? ;
	[GrammarRule("variableDeclaration")]
	private VariableDeclaration variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 57);
		TraceIn("variableDeclaration", 57);
		VariableDeclaration value = default(VariableDeclaration);

		IToken id = default(IToken);
		ExpressionSyntax ass = default(ExpressionSyntax);


			ExpressionSyntax expression = null;

		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(1556, 1);
		try
		{
			// EcmaScript.g:1560:2: (id= Identifier ( ASSIGN ass= assignmentExpression )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1561:9: id= Identifier ( ASSIGN ass= assignmentExpression )?
			{
			DebugLocation(1561, 11);
			id=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration7267); 
			DebugLocation(1562, 9);
			// EcmaScript.g:1562:9: ( ASSIGN ass= assignmentExpression )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==ASSIGN))
			{
				alt64 = 1;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1563:13: ASSIGN ass= assignmentExpression
				{
				DebugLocation(1563, 13);
				Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclaration7291); 
				DebugLocation(1563, 23);
				PushFollow(Follow._assignmentExpression_in_variableDeclaration7295);
				ass=assignmentExpression();
				PopFollow();

				DebugLocation(1564, 13);
				 expression = ass; 

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(1566, 9);
			 value = _builder.BuildVariableDeclaration(id.Text, expression, true); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variableDeclaration", 57);
			LeaveRule("variableDeclaration", 57);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(1567, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return value;

	}
	// $ANTLR end "variableDeclaration"


	partial void EnterRule_variableDeclarationNoIn();
	partial void LeaveRule_variableDeclarationNoIn();

	// $ANTLR start "variableDeclarationNoIn"
	// EcmaScript.g:1569:1: variableDeclarationNoIn returns [VariableDeclaration value] : id= Identifier ( ASSIGN ass= assignmentExpressionNoIn )? ;
	[GrammarRule("variableDeclarationNoIn")]
	private VariableDeclaration variableDeclarationNoIn()
	{
		EnterRule_variableDeclarationNoIn();
		EnterRule("variableDeclarationNoIn", 58);
		TraceIn("variableDeclarationNoIn", 58);
		VariableDeclaration value = default(VariableDeclaration);

		IToken id = default(IToken);
		ExpressionSyntax ass = default(ExpressionSyntax);


			ExpressionSyntax expression = null;

		try { DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
		DebugLocation(1569, 1);
		try
		{
			// EcmaScript.g:1573:2: (id= Identifier ( ASSIGN ass= assignmentExpressionNoIn )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1574:9: id= Identifier ( ASSIGN ass= assignmentExpressionNoIn )?
			{
			DebugLocation(1574, 11);
			id=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclarationNoIn7361); 
			DebugLocation(1575, 9);
			// EcmaScript.g:1575:9: ( ASSIGN ass= assignmentExpressionNoIn )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_0 = input.LA(1);

			if ((LA65_0==ASSIGN))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1576:13: ASSIGN ass= assignmentExpressionNoIn
				{
				DebugLocation(1576, 13);
				Match(input,ASSIGN,Follow._ASSIGN_in_variableDeclarationNoIn7385); 
				DebugLocation(1576, 23);
				PushFollow(Follow._assignmentExpressionNoIn_in_variableDeclarationNoIn7389);
				ass=assignmentExpressionNoIn();
				PopFollow();

				DebugLocation(1577, 13);
				 expression = ass; 

				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(1579, 9);
			 value = _builder.BuildVariableDeclaration(id.Text, expression, true); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("variableDeclarationNoIn", 58);
			LeaveRule("variableDeclarationNoIn", 58);
			LeaveRule_variableDeclarationNoIn();
		}
		DebugLocation(1580, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
		return value;

	}
	// $ANTLR end "variableDeclarationNoIn"


	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();

	// $ANTLR start "emptyStatement"
	// EcmaScript.g:1586:1: emptyStatement returns [SyntaxNode value] : SEMIC ;
	[GrammarRule("emptyStatement")]
	private SyntaxNode emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 59);
		TraceIn("emptyStatement", 59);
		SyntaxNode value = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(1586, 1);
		try
		{
			// EcmaScript.g:1587:2: ( SEMIC )
			DebugEnterAlt(1);
			// EcmaScript.g:1587:4: SEMIC
			{
			DebugLocation(1587, 4);
			Match(input,SEMIC,Follow._SEMIC_in_emptyStatement7444); 
			DebugLocation(1587, 10);
			 value = _builder.BuildEmpty(); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("emptyStatement", 59);
			LeaveRule("emptyStatement", 59);
			LeaveRule_emptyStatement();
		}
		DebugLocation(1588, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		return value;

	}
	// $ANTLR end "emptyStatement"


	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();

	// $ANTLR start "expressionStatement"
	// EcmaScript.g:1601:1: expressionStatement returns [SyntaxNode value] : e= expression semic ;
	[GrammarRule("expressionStatement")]
	private SyntaxNode expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 60);
		TraceIn("expressionStatement", 60);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax e = default(ExpressionSyntax);


		    var start = input.LT(1);

		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(1601, 1);
		try
		{
			// EcmaScript.g:1605:2: (e= expression semic )
			DebugEnterAlt(1);
			// EcmaScript.g:1606:9: e= expression semic
			{
			DebugLocation(1606, 10);
			PushFollow(Follow._expression_in_expressionStatement7483);
			e=expression();
			PopFollow();

			DebugLocation(1606, 22);
			PushFollow(Follow._semic_in_expressionStatement7485);
			semic();
			PopFollow();

			DebugLocation(1607, 9);
			 value = _builder.BuildExpressionStatement(e, GetLocation(start, input.LT(-1))); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expressionStatement", 60);
			LeaveRule("expressionStatement", 60);
			LeaveRule_expressionStatement();
		}
		DebugLocation(1608, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return value;

	}
	// $ANTLR end "expressionStatement"


	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();

	// $ANTLR start "ifStatement"
	// EcmaScript.g:1614:1: ifStatement returns [SyntaxNode value] : IF LPAREN e= expression RPAREN then= statement ({...}? ELSE els= statement )? ;
	[GrammarRule("ifStatement")]
	private SyntaxNode ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 61);
		TraceIn("ifStatement", 61);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax e = default(ExpressionSyntax);
		SyntaxNode then = default(SyntaxNode);
		SyntaxNode els = default(SyntaxNode);


		    SyntaxNode elseStatement = null;
		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(1614, 1);
		try
		{
			// EcmaScript.g:1621:2: ( IF LPAREN e= expression RPAREN then= statement ({...}? ELSE els= statement )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1622:9: IF LPAREN e= expression RPAREN then= statement ({...}? ELSE els= statement )?
			{
			DebugLocation(1622, 9);
			Match(input,IF,Follow._IF_in_ifStatement7529); 
			DebugLocation(1622, 12);
			Match(input,LPAREN,Follow._LPAREN_in_ifStatement7531); 
			DebugLocation(1622, 20);
			PushFollow(Follow._expression_in_ifStatement7535);
			e=expression();
			PopFollow();

			DebugLocation(1622, 32);
			Match(input,RPAREN,Follow._RPAREN_in_ifStatement7537); 
			DebugLocation(1623, 9);
			 end = input.LT(-1); 
			DebugLocation(1624, 13);
			PushFollow(Follow._statement_in_ifStatement7559);
			then=statement();
			PopFollow();

			DebugLocation(1625, 9);
			// EcmaScript.g:1625:9: ({...}? ELSE els= statement )?
			int alt66=2;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			int LA66_0 = input.LA(1);

			if ((LA66_0==ELSE))
			{
				int LA66_1 = input.LA(2);

				if ((( input.LA(1) == ELSE )))
				{
					alt66 = 1;
				}
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1626:13: {...}? ELSE els= statement
				{
				DebugLocation(1626, 13);
				if (!(( input.LA(1) == ELSE )))
				{
					throw new FailedPredicateException(input, "ifStatement", " input.LA(1) == ELSE ");
				}
				DebugLocation(1627, 13);
				Match(input,ELSE,Follow._ELSE_in_ifStatement7597); 
				DebugLocation(1627, 21);
				PushFollow(Follow._statement_in_ifStatement7601);
				els=statement();
				PopFollow();

				DebugLocation(1628, 13);
				 elseStatement = els; 

				}
				break;

			}
			} finally { DebugExitSubRule(66); }

			DebugLocation(1630, 9);
			 value = _builder.BuildIf(e, then, elseStatement, GetLocation(start, end)); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("ifStatement", 61);
			LeaveRule("ifStatement", 61);
			LeaveRule_ifStatement();
		}
		DebugLocation(1631, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return value;

	}
	// $ANTLR end "ifStatement"


	partial void EnterRule_iterationStatement();
	partial void LeaveRule_iterationStatement();

	// $ANTLR start "iterationStatement"
	// EcmaScript.g:1637:1: iterationStatement returns [SyntaxNode value] : (dos= doStatement |wh= whileStatement |fo= forStatement );
	[GrammarRule("iterationStatement")]
	private SyntaxNode iterationStatement()
	{
		EnterRule_iterationStatement();
		EnterRule("iterationStatement", 62);
		TraceIn("iterationStatement", 62);
		SyntaxNode value = default(SyntaxNode);

		SyntaxNode dos = default(SyntaxNode);
		SyntaxNode wh = default(SyntaxNode);
		SyntaxNode fo = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "iterationStatement");
		DebugLocation(1637, 1);
		try
		{
			// EcmaScript.g:1638:2: (dos= doStatement |wh= whileStatement |fo= forStatement )
			int alt67=3;
			try { DebugEnterDecision(67, false);
			switch (input.LA(1))
			{
			case DO:
				{
				alt67 = 1;
				}
				break;
			case WHILE:
				{
				alt67 = 2;
				}
				break;
			case FOR:
				{
				alt67 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 67, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1638:4: dos= doStatement
				{
				DebugLocation(1638, 7);
				PushFollow(Follow._doStatement_in_iterationStatement7658);
				dos=doStatement();
				PopFollow();

				DebugLocation(1638, 20);
				 value = dos; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1639:4: wh= whileStatement
				{
				DebugLocation(1639, 6);
				PushFollow(Follow._whileStatement_in_iterationStatement7667);
				wh=whileStatement();
				PopFollow();

				DebugLocation(1639, 23);
				 value = wh; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:1640:4: fo= forStatement
				{
				DebugLocation(1640, 6);
				PushFollow(Follow._forStatement_in_iterationStatement7677);
				fo=forStatement();
				PopFollow();

				DebugLocation(1640, 21);
				 value = fo; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("iterationStatement", 62);
			LeaveRule("iterationStatement", 62);
			LeaveRule_iterationStatement();
		}
		DebugLocation(1641, 1);
		} finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
		return value;

	}
	// $ANTLR end "iterationStatement"


	partial void EnterRule_doStatement();
	partial void LeaveRule_doStatement();

	// $ANTLR start "doStatement"
	// EcmaScript.g:1643:1: doStatement returns [SyntaxNode value] : DO st= statement WHILE LPAREN e= expression RPAREN semic ;
	[GrammarRule("doStatement")]
	private SyntaxNode doStatement()
	{
		EnterRule_doStatement();
		EnterRule("doStatement", 63);
		TraceIn("doStatement", 63);
		SyntaxNode value = default(SyntaxNode);

		SyntaxNode st = default(SyntaxNode);
		ExpressionSyntax e = default(ExpressionSyntax);


		    IToken start;

		try { DebugEnterRule(GrammarFileName, "doStatement");
		DebugLocation(1643, 1);
		try
		{
			// EcmaScript.g:1647:2: ( DO st= statement WHILE LPAREN e= expression RPAREN semic )
			DebugEnterAlt(1);
			// EcmaScript.g:1648:9: DO st= statement WHILE LPAREN e= expression RPAREN semic
			{
			DebugLocation(1648, 9);
			Match(input,DO,Follow._DO_in_doStatement7709); 
			DebugLocation(1648, 14);
			PushFollow(Follow._statement_in_doStatement7713);
			st=statement();
			PopFollow();

			DebugLocation(1649, 9);
			 start = input.LT(1); 
			DebugLocation(1650, 9);
			Match(input,WHILE,Follow._WHILE_in_doStatement7733); 
			DebugLocation(1650, 15);
			Match(input,LPAREN,Follow._LPAREN_in_doStatement7735); 
			DebugLocation(1650, 23);
			PushFollow(Follow._expression_in_doStatement7739);
			e=expression();
			PopFollow();

			DebugLocation(1650, 35);
			Match(input,RPAREN,Follow._RPAREN_in_doStatement7741); 
			DebugLocation(1650, 42);
			PushFollow(Follow._semic_in_doStatement7743);
			semic();
			PopFollow();

			DebugLocation(1651, 9);
			 value = _builder.BuildDoWhile(e, st, GetLocation(start, input.LT(-1))); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("doStatement", 63);
			LeaveRule("doStatement", 63);
			LeaveRule_doStatement();
		}
		DebugLocation(1652, 1);
		} finally { DebugExitRule(GrammarFileName, "doStatement"); }
		return value;

	}
	// $ANTLR end "doStatement"


	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();

	// $ANTLR start "whileStatement"
	// EcmaScript.g:1654:1: whileStatement returns [SyntaxNode value] : WHILE LPAREN e= expression RPAREN st= statement ;
	[GrammarRule("whileStatement")]
	private SyntaxNode whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 64);
		TraceIn("whileStatement", 64);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax e = default(ExpressionSyntax);
		SyntaxNode st = default(SyntaxNode);


		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(1654, 1);
		try
		{
			// EcmaScript.g:1659:2: ( WHILE LPAREN e= expression RPAREN st= statement )
			DebugEnterAlt(1);
			// EcmaScript.g:1660:9: WHILE LPAREN e= expression RPAREN st= statement
			{
			DebugLocation(1660, 9);
			Match(input,WHILE,Follow._WHILE_in_whileStatement7782); 
			DebugLocation(1660, 15);
			Match(input,LPAREN,Follow._LPAREN_in_whileStatement7784); 
			DebugLocation(1660, 23);
			PushFollow(Follow._expression_in_whileStatement7788);
			e=expression();
			PopFollow();

			DebugLocation(1660, 35);
			Match(input,RPAREN,Follow._RPAREN_in_whileStatement7790); 
			DebugLocation(1661, 9);
			 end = input.LT(-1); 
			DebugLocation(1662, 11);
			PushFollow(Follow._statement_in_whileStatement7812);
			st=statement();
			PopFollow();

			DebugLocation(1663, 9);
			 value = _builder.BuildWhile(e, st, GetLocation(start, end)); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("whileStatement", 64);
			LeaveRule("whileStatement", 64);
			LeaveRule_whileStatement();
		}
		DebugLocation(1664, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return value;

	}
	// $ANTLR end "whileStatement"


	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();

	// $ANTLR start "forStatement"
	// EcmaScript.g:1708:1: forStatement returns [SyntaxNode value] : FOR LPAREN fo= forControl RPAREN st= statement ;
	[GrammarRule("forStatement")]
	private SyntaxNode forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 65);
		TraceIn("forStatement", 65);
		SyntaxNode value = default(SyntaxNode);

		ForBuilder fo = default(ForBuilder);
		SyntaxNode st = default(SyntaxNode);


		    ForBuilder builder;
		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(1708, 1);
		try
		{
			// EcmaScript.g:1717:2: ( FOR LPAREN fo= forControl RPAREN st= statement )
			DebugEnterAlt(1);
			// EcmaScript.g:1718:9: FOR LPAREN fo= forControl RPAREN st= statement
			{
			DebugLocation(1718, 9);
			Match(input,FOR,Follow._FOR_in_forStatement7857); 
			DebugLocation(1719, 9);
			Match(input,LPAREN,Follow._LPAREN_in_forStatement7867); 
			DebugLocation(1720, 11);
			PushFollow(Follow._forControl_in_forStatement7879);
			fo=forControl();
			PopFollow();

			DebugLocation(1721, 9);
			 builder = fo; 
			DebugLocation(1722, 9);
			Match(input,RPAREN,Follow._RPAREN_in_forStatement7899); 
			DebugLocation(1723, 9);
			 end = input.LT(-1); 
			DebugLocation(1724, 11);
			PushFollow(Follow._statement_in_forStatement7921);
			st=statement();
			PopFollow();

			DebugLocation(1725, 9);
			 builder.Body = st; 

			}


			    value = builder.BuildFor(this, GetLocation(start, end));

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forStatement", 65);
			LeaveRule("forStatement", 65);
			LeaveRule_forStatement();
		}
		DebugLocation(1726, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return value;

	}
	// $ANTLR end "forStatement"


	partial void EnterRule_forControl();
	partial void LeaveRule_forControl();

	// $ANTLR start "forControl"
	// EcmaScript.g:1728:1: forControl returns [ForBuilder value] : (ex1= forControlVar |ex2= forControlExpression |ex3= forControlSemic );
	[GrammarRule("forControl")]
	private ForBuilder forControl()
	{
		EnterRule_forControl();
		EnterRule("forControl", 66);
		TraceIn("forControl", 66);
		ForBuilder value = default(ForBuilder);

		ForBuilder ex1 = default(ForBuilder);
		ForBuilder ex2 = default(ForBuilder);
		ForBuilder ex3 = default(ForBuilder);

		try { DebugEnterRule(GrammarFileName, "forControl");
		DebugLocation(1728, 1);
		try
		{
			// EcmaScript.g:1729:2: (ex1= forControlVar |ex2= forControlExpression |ex3= forControlSemic )
			int alt68=3;
			try { DebugEnterDecision(68, false);
			switch (input.LA(1))
			{
			case VAR:
				{
				alt68 = 1;
				}
				break;
			case ADD:
			case DEC:
			case DELETE:
			case DecimalLiteral:
			case FALSE:
			case FUNCTION:
			case HexIntegerLiteral:
			case INC:
			case INV:
			case Identifier:
			case LBRACE:
			case LBRACK:
			case LPAREN:
			case NEW:
			case NOT:
			case NULL:
			case OctalIntegerLiteral:
			case RegularExpressionLiteral:
			case SUB:
			case StringLiteral:
			case THIS:
			case TRUE:
			case TYPEOF:
			case VOID:
				{
				alt68 = 2;
				}
				break;
			case SEMIC:
				{
				alt68 = 3;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 68, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1730:9: ex1= forControlVar
				{
				DebugLocation(1730, 12);
				PushFollow(Follow._forControlVar_in_forControl7956);
				ex1=forControlVar();
				PopFollow();

				DebugLocation(1731, 9);
				 value = ex1; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1733:9: ex2= forControlExpression
				{
				DebugLocation(1733, 12);
				PushFollow(Follow._forControlExpression_in_forControl7981);
				ex2=forControlExpression();
				PopFollow();

				DebugLocation(1734, 9);
				 value = ex2; 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// EcmaScript.g:1736:9: ex3= forControlSemic
				{
				DebugLocation(1736, 12);
				PushFollow(Follow._forControlSemic_in_forControl8006);
				ex3=forControlSemic();
				PopFollow();

				DebugLocation(1737, 9);
				 value = ex3; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forControl", 66);
			LeaveRule("forControl", 66);
			LeaveRule_forControl();
		}
		DebugLocation(1738, 1);
		} finally { DebugExitRule(GrammarFileName, "forControl"); }
		return value;

	}
	// $ANTLR end "forControl"


	partial void EnterRule_forControlVar();
	partial void LeaveRule_forControlVar();

	// $ANTLR start "forControlVar"
	// EcmaScript.g:1740:1: forControlVar returns [ForBuilder value] : VAR first= variableDeclarationNoIn ( ( IN ex= expression ) | ( ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) ) ;
	[GrammarRule("forControlVar")]
	private ForBuilder forControlVar()
	{
		EnterRule_forControlVar();
		EnterRule("forControlVar", 67);
		TraceIn("forControlVar", 67);
		ForBuilder value = default(ForBuilder);

		VariableDeclaration first = default(VariableDeclaration);
		ExpressionSyntax ex = default(ExpressionSyntax);
		VariableDeclaration follow = default(VariableDeclaration);
		ExpressionSyntax ex1 = default(ExpressionSyntax);
		ExpressionSyntax ex2 = default(ExpressionSyntax);


		    value = new ForBuilder(_builder);
		    var declarations = new ReadOnlyArray<VariableDeclaration>.Builder();
		    IToken start;
		    IToken end = null;

		try { DebugEnterRule(GrammarFileName, "forControlVar");
		DebugLocation(1740, 1);
		try
		{
			// EcmaScript.g:1750:2: ( VAR first= variableDeclarationNoIn ( ( IN ex= expression ) | ( ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) ) )
			DebugEnterAlt(1);
			// EcmaScript.g:1751:9: VAR first= variableDeclarationNoIn ( ( IN ex= expression ) | ( ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) )
			{
			DebugLocation(1751, 9);
			 start = input.LT(1); 
			DebugLocation(1752, 9);
			Match(input,VAR,Follow._VAR_in_forControlVar8059); 
			DebugLocation(1752, 18);
			PushFollow(Follow._variableDeclarationNoIn_in_forControlVar8063);
			first=variableDeclarationNoIn();
			PopFollow();

			DebugLocation(1753, 9);
			 declarations.Add(first); 
			DebugLocation(1754, 6);
			// EcmaScript.g:1754:6: ( ( IN ex= expression ) | ( ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? ) )
			int alt72=2;
			try { DebugEnterSubRule(72);
			try { DebugEnterDecision(72, false);
			int LA72_0 = input.LA(1);

			if ((LA72_0==IN))
			{
				alt72 = 1;
			}
			else if ((LA72_0==COMMA||LA72_0==SEMIC))
			{
				alt72 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 72, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(72); }
			switch (alt72)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1755:7: ( IN ex= expression )
				{
				DebugLocation(1755, 7);
				// EcmaScript.g:1755:7: ( IN ex= expression )
				DebugEnterAlt(1);
				// EcmaScript.g:1756:17: IN ex= expression
				{
				DebugLocation(1756, 17);
				 end = input.LT(-1); 
				DebugLocation(1757, 8);
				Match(input,IN,Follow._IN_in_forControlVar8115); 
				DebugLocation(1757, 13);
				PushFollow(Follow._expression_in_forControlVar8119);
				ex=expression();
				PopFollow();

				DebugLocation(1758, 17);
				 value.Expression = ex; 

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1761:7: ( ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? )
				{
				DebugLocation(1761, 7);
				// EcmaScript.g:1761:7: ( ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )? )
				DebugEnterAlt(1);
				// EcmaScript.g:1762:8: ( COMMA follow= variableDeclarationNoIn )* SEMIC (ex1= expression )? SEMIC (ex2= expression )?
				{
				DebugLocation(1762, 8);
				// EcmaScript.g:1762:8: ( COMMA follow= variableDeclarationNoIn )*
				try { DebugEnterSubRule(69);
				while (true)
				{
					int alt69=2;
					try { DebugEnterDecision(69, false);
					int LA69_0 = input.LA(1);

					if ((LA69_0==COMMA))
					{
						alt69 = 1;
					}


					} finally { DebugExitDecision(69); }
					switch ( alt69 )
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:1763:21: COMMA follow= variableDeclarationNoIn
						{
						DebugLocation(1763, 21);
						Match(input,COMMA,Follow._COMMA_in_forControlVar8192); 
						DebugLocation(1763, 33);
						PushFollow(Follow._variableDeclarationNoIn_in_forControlVar8196);
						follow=variableDeclarationNoIn();
						PopFollow();

						DebugLocation(1764, 21);
						 declarations.Add(follow); 

						}
						break;

					default:
						goto loop69;
					}
				}

				loop69:
					;

				} finally { DebugExitSubRule(69); }

				DebugLocation(1766, 17);
				 end = input.LT(-1); 
				DebugLocation(1767, 8);
				Match(input,SEMIC,Follow._SEMIC_in_forControlVar8264); 
				DebugLocation(1768, 17);
				// EcmaScript.g:1768:17: (ex1= expression )?
				int alt70=2;
				try { DebugEnterSubRule(70);
				try { DebugEnterDecision(70, false);
				int LA70_0 = input.LA(1);

				if ((LA70_0==ADD||LA70_0==DEC||LA70_0==DELETE||LA70_0==DecimalLiteral||LA70_0==FALSE||LA70_0==FUNCTION||LA70_0==HexIntegerLiteral||LA70_0==INC||LA70_0==INV||LA70_0==Identifier||(LA70_0>=LBRACE && LA70_0<=LBRACK)||LA70_0==LPAREN||(LA70_0>=NEW && LA70_0<=NOT)||LA70_0==NULL||LA70_0==OctalIntegerLiteral||LA70_0==RegularExpressionLiteral||LA70_0==SUB||LA70_0==StringLiteral||LA70_0==THIS||LA70_0==TRUE||LA70_0==TYPEOF||LA70_0==VOID))
				{
					alt70 = 1;
				}
				} finally { DebugExitDecision(70); }
				switch (alt70)
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1769:21: ex1= expression
					{
					DebugLocation(1769, 24);
					PushFollow(Follow._expression_in_forControlVar8306);
					ex1=expression();
					PopFollow();

					DebugLocation(1770, 21);
					 value.Test = ex1;

					}
					break;

				}
				} finally { DebugExitSubRule(70); }

				DebugLocation(1772, 17);
				Match(input,SEMIC,Follow._SEMIC_in_forControlVar8365); 
				DebugLocation(1773, 17);
				// EcmaScript.g:1773:17: (ex2= expression )?
				int alt71=2;
				try { DebugEnterSubRule(71);
				try { DebugEnterDecision(71, false);
				int LA71_0 = input.LA(1);

				if ((LA71_0==ADD||LA71_0==DEC||LA71_0==DELETE||LA71_0==DecimalLiteral||LA71_0==FALSE||LA71_0==FUNCTION||LA71_0==HexIntegerLiteral||LA71_0==INC||LA71_0==INV||LA71_0==Identifier||(LA71_0>=LBRACE && LA71_0<=LBRACK)||LA71_0==LPAREN||(LA71_0>=NEW && LA71_0<=NOT)||LA71_0==NULL||LA71_0==OctalIntegerLiteral||LA71_0==RegularExpressionLiteral||LA71_0==SUB||LA71_0==StringLiteral||LA71_0==THIS||LA71_0==TRUE||LA71_0==TYPEOF||LA71_0==VOID))
				{
					alt71 = 1;
				}
				} finally { DebugExitDecision(71); }
				switch (alt71)
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1774:21: ex2= expression
					{
					DebugLocation(1774, 24);
					PushFollow(Follow._expression_in_forControlVar8407);
					ex2=expression();
					PopFollow();

					DebugLocation(1775, 21);
					 value.Increment = ex2; 

					}
					break;

				}
				} finally { DebugExitSubRule(71); }


				}


				}
				break;

			}
			} finally { DebugExitSubRule(72); }


			}


			    value.Initialization = _builder.BuildVariableDeclaration(declarations.ToReadOnly(), GetLocation(start, end));

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forControlVar", 67);
			LeaveRule("forControlVar", 67);
			LeaveRule_forControlVar();
		}
		DebugLocation(1779, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlVar"); }
		return value;

	}
	// $ANTLR end "forControlVar"


	partial void EnterRule_forControlExpression();
	partial void LeaveRule_forControlExpression();

	// $ANTLR start "forControlExpression"
	// EcmaScript.g:1781:1: forControlExpression returns [ForBuilder value] : ex1= expressionNoIn ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) ) ;
	[GrammarRule("forControlExpression")]
	private ForBuilder forControlExpression()
	{
		EnterRule_forControlExpression();
		EnterRule("forControlExpression", 68);
		TraceIn("forControlExpression", 68);
		ForBuilder value = default(ForBuilder);

		ExpressionSyntax ex1 = default(ExpressionSyntax);
		ExpressionSyntax ex2 = default(ExpressionSyntax);
		ExpressionSyntax ex3 = default(ExpressionSyntax);


		    value = new ForBuilder(_builder);
			bool isLhs;

		try { DebugEnterRule(GrammarFileName, "forControlExpression");
		DebugLocation(1781, 1);
		try
		{
			// EcmaScript.g:1787:2: (ex1= expressionNoIn ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) ) )
			DebugEnterAlt(1);
			// EcmaScript.g:1788:9: ex1= expressionNoIn ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) )
			{
			DebugLocation(1788, 12);
			PushFollow(Follow._expressionNoIn_in_forControlExpression8493);
			ex1=expressionNoIn();
			PopFollow();

			DebugLocation(1789, 9);
			 value.Initialization = ex1; isLhs = IsLeftHandSideIn(ex1); 
			DebugLocation(1790, 6);
			// EcmaScript.g:1790:6: ({...}? ( IN ex2= expression ) | ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? ) )
			int alt75=2;
			try { DebugEnterSubRule(75);
			try { DebugEnterDecision(75, false);
			int LA75_0 = input.LA(1);

			if ((LA75_0==IN))
			{
				alt75 = 1;
			}
			else if ((LA75_0==SEMIC))
			{
				alt75 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 75, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(75); }
			switch (alt75)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1791:7: {...}? ( IN ex2= expression )
				{
				DebugLocation(1791, 7);
				if (!(( isLhs )))
				{
					throw new FailedPredicateException(input, "forControlExpression", " isLhs ");
				}
				DebugLocation(1792, 13);
				// EcmaScript.g:1792:13: ( IN ex2= expression )
				DebugEnterAlt(1);
				// EcmaScript.g:1793:8: IN ex2= expression
				{
				DebugLocation(1793, 8);
				Match(input,IN,Follow._IN_in_forControlExpression8542); 
				DebugLocation(1793, 14);
				PushFollow(Follow._expression_in_forControlExpression8546);
				ex2=expression();
				PopFollow();

				DebugLocation(1794, 17);
				 value.Expression = ex2; 

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:1797:7: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? )
				{
				DebugLocation(1797, 7);
				// EcmaScript.g:1797:7: ( SEMIC (ex2= expression )? SEMIC (ex3= expression )? )
				DebugEnterAlt(1);
				// EcmaScript.g:1798:8: SEMIC (ex2= expression )? SEMIC (ex3= expression )?
				{
				DebugLocation(1798, 8);
				Match(input,SEMIC,Follow._SEMIC_in_forControlExpression8597); 
				DebugLocation(1799, 17);
				// EcmaScript.g:1799:17: (ex2= expression )?
				int alt73=2;
				try { DebugEnterSubRule(73);
				try { DebugEnterDecision(73, false);
				int LA73_0 = input.LA(1);

				if ((LA73_0==ADD||LA73_0==DEC||LA73_0==DELETE||LA73_0==DecimalLiteral||LA73_0==FALSE||LA73_0==FUNCTION||LA73_0==HexIntegerLiteral||LA73_0==INC||LA73_0==INV||LA73_0==Identifier||(LA73_0>=LBRACE && LA73_0<=LBRACK)||LA73_0==LPAREN||(LA73_0>=NEW && LA73_0<=NOT)||LA73_0==NULL||LA73_0==OctalIntegerLiteral||LA73_0==RegularExpressionLiteral||LA73_0==SUB||LA73_0==StringLiteral||LA73_0==THIS||LA73_0==TRUE||LA73_0==TYPEOF||LA73_0==VOID))
				{
					alt73 = 1;
				}
				} finally { DebugExitDecision(73); }
				switch (alt73)
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1800:21: ex2= expression
					{
					DebugLocation(1800, 24);
					PushFollow(Follow._expression_in_forControlExpression8639);
					ex2=expression();
					PopFollow();

					DebugLocation(1801, 21);
					 value.Test = ex2;

					}
					break;

				}
				} finally { DebugExitSubRule(73); }

				DebugLocation(1803, 17);
				Match(input,SEMIC,Follow._SEMIC_in_forControlExpression8698); 
				DebugLocation(1804, 17);
				// EcmaScript.g:1804:17: (ex3= expression )?
				int alt74=2;
				try { DebugEnterSubRule(74);
				try { DebugEnterDecision(74, false);
				int LA74_0 = input.LA(1);

				if ((LA74_0==ADD||LA74_0==DEC||LA74_0==DELETE||LA74_0==DecimalLiteral||LA74_0==FALSE||LA74_0==FUNCTION||LA74_0==HexIntegerLiteral||LA74_0==INC||LA74_0==INV||LA74_0==Identifier||(LA74_0>=LBRACE && LA74_0<=LBRACK)||LA74_0==LPAREN||(LA74_0>=NEW && LA74_0<=NOT)||LA74_0==NULL||LA74_0==OctalIntegerLiteral||LA74_0==RegularExpressionLiteral||LA74_0==SUB||LA74_0==StringLiteral||LA74_0==THIS||LA74_0==TRUE||LA74_0==TYPEOF||LA74_0==VOID))
				{
					alt74 = 1;
				}
				} finally { DebugExitDecision(74); }
				switch (alt74)
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1805:21: ex3= expression
					{
					DebugLocation(1805, 24);
					PushFollow(Follow._expression_in_forControlExpression8740);
					ex3=expression();
					PopFollow();

					DebugLocation(1806, 21);
					 value.Increment = ex3; 

					}
					break;

				}
				} finally { DebugExitSubRule(74); }


				}


				}
				break;

			}
			} finally { DebugExitSubRule(75); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forControlExpression", 68);
			LeaveRule("forControlExpression", 68);
			LeaveRule_forControlExpression();
		}
		DebugLocation(1810, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlExpression"); }
		return value;

	}
	// $ANTLR end "forControlExpression"


	partial void EnterRule_forControlSemic();
	partial void LeaveRule_forControlSemic();

	// $ANTLR start "forControlSemic"
	// EcmaScript.g:1812:1: forControlSemic returns [ForBuilder value] : SEMIC (ex1= expression )? SEMIC (ex2= expression )? ;
	[GrammarRule("forControlSemic")]
	private ForBuilder forControlSemic()
	{
		EnterRule_forControlSemic();
		EnterRule("forControlSemic", 69);
		TraceIn("forControlSemic", 69);
		ForBuilder value = default(ForBuilder);

		ExpressionSyntax ex1 = default(ExpressionSyntax);
		ExpressionSyntax ex2 = default(ExpressionSyntax);


			value = new ForBuilder(_builder);

		try { DebugEnterRule(GrammarFileName, "forControlSemic");
		DebugLocation(1812, 1);
		try
		{
			// EcmaScript.g:1816:2: ( SEMIC (ex1= expression )? SEMIC (ex2= expression )? )
			DebugEnterAlt(1);
			// EcmaScript.g:1817:9: SEMIC (ex1= expression )? SEMIC (ex2= expression )?
			{
			DebugLocation(1817, 9);
			Match(input,SEMIC,Follow._SEMIC_in_forControlSemic8823); 
			DebugLocation(1818, 9);
			// EcmaScript.g:1818:9: (ex1= expression )?
			int alt76=2;
			try { DebugEnterSubRule(76);
			try { DebugEnterDecision(76, false);
			int LA76_0 = input.LA(1);

			if ((LA76_0==ADD||LA76_0==DEC||LA76_0==DELETE||LA76_0==DecimalLiteral||LA76_0==FALSE||LA76_0==FUNCTION||LA76_0==HexIntegerLiteral||LA76_0==INC||LA76_0==INV||LA76_0==Identifier||(LA76_0>=LBRACE && LA76_0<=LBRACK)||LA76_0==LPAREN||(LA76_0>=NEW && LA76_0<=NOT)||LA76_0==NULL||LA76_0==OctalIntegerLiteral||LA76_0==RegularExpressionLiteral||LA76_0==SUB||LA76_0==StringLiteral||LA76_0==THIS||LA76_0==TRUE||LA76_0==TYPEOF||LA76_0==VOID))
			{
				alt76 = 1;
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1819:13: ex1= expression
				{
				DebugLocation(1819, 16);
				PushFollow(Follow._expression_in_forControlSemic8849);
				ex1=expression();
				PopFollow();

				DebugLocation(1820, 13);
				 value.Test = ex1;

				}
				break;

			}
			} finally { DebugExitSubRule(76); }

			DebugLocation(1822, 9);
			Match(input,SEMIC,Follow._SEMIC_in_forControlSemic8884); 
			DebugLocation(1823, 9);
			// EcmaScript.g:1823:9: (ex2= expression )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_0 = input.LA(1);

			if ((LA77_0==ADD||LA77_0==DEC||LA77_0==DELETE||LA77_0==DecimalLiteral||LA77_0==FALSE||LA77_0==FUNCTION||LA77_0==HexIntegerLiteral||LA77_0==INC||LA77_0==INV||LA77_0==Identifier||(LA77_0>=LBRACE && LA77_0<=LBRACK)||LA77_0==LPAREN||(LA77_0>=NEW && LA77_0<=NOT)||LA77_0==NULL||LA77_0==OctalIntegerLiteral||LA77_0==RegularExpressionLiteral||LA77_0==SUB||LA77_0==StringLiteral||LA77_0==THIS||LA77_0==TRUE||LA77_0==TYPEOF||LA77_0==VOID))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1824:13: ex2= expression
				{
				DebugLocation(1824, 16);
				PushFollow(Follow._expression_in_forControlSemic8910);
				ex2=expression();
				PopFollow();

				DebugLocation(1825, 13);
				 value.Increment = ex2; 

				}
				break;

			}
			} finally { DebugExitSubRule(77); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("forControlSemic", 69);
			LeaveRule("forControlSemic", 69);
			LeaveRule_forControlSemic();
		}
		DebugLocation(1827, 1);
		} finally { DebugExitRule(GrammarFileName, "forControlSemic"); }
		return value;

	}
	// $ANTLR end "forControlSemic"


	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();

	// $ANTLR start "continueStatement"
	// EcmaScript.g:1839:1: continueStatement returns [SyntaxNode value] : CONTINUE (lb= Identifier )? semic ;
	[GrammarRule("continueStatement")]
	private SyntaxNode continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 70);
		TraceIn("continueStatement", 70);
		SyntaxNode value = default(SyntaxNode);

		IToken lb = default(IToken);

		 
			string label = null;
		    var start = input.LT(1);

		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(1839, 1);
		try
		{
			// EcmaScript.g:1844:2: ( CONTINUE (lb= Identifier )? semic )
			DebugEnterAlt(1);
			// EcmaScript.g:1845:9: CONTINUE (lb= Identifier )? semic
			{
			DebugLocation(1845, 9);
			Match(input,CONTINUE,Follow._CONTINUE_in_continueStatement8970); 
			DebugLocation(1846, 9);

						if (input.LA(1) == Identifier)
							PromoteEol();
					
			DebugLocation(1850, 9);
			// EcmaScript.g:1850:9: (lb= Identifier )?
			int alt78=2;
			try { DebugEnterSubRule(78);
			try { DebugEnterDecision(78, false);
			int LA78_0 = input.LA(1);

			if ((LA78_0==Identifier))
			{
				alt78 = 1;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1851:13: lb= Identifier
				{
				DebugLocation(1851, 15);
				lb=(IToken)Match(input,Identifier,Follow._Identifier_in_continueStatement9006); 
				DebugLocation(1852, 13);
				 label = lb.Text; 

				}
				break;

			}
			} finally { DebugExitSubRule(78); }

			DebugLocation(1854, 9);
			PushFollow(Follow._semic_in_continueStatement9041);
			semic();
			PopFollow();

			DebugLocation(1855, 9);
			 value = _builder.BuildContinue(label, GetLocation(start, input.LT(-1))); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("continueStatement", 70);
			LeaveRule("continueStatement", 70);
			LeaveRule_continueStatement();
		}
		DebugLocation(1856, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return value;

	}
	// $ANTLR end "continueStatement"


	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();

	// $ANTLR start "breakStatement"
	// EcmaScript.g:1868:1: breakStatement returns [SyntaxNode value] : BREAK (lb= Identifier )? semic ;
	[GrammarRule("breakStatement")]
	private SyntaxNode breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 71);
		TraceIn("breakStatement", 71);
		SyntaxNode value = default(SyntaxNode);

		IToken lb = default(IToken);

		 
			string label = null;
		    var start = input.LT(1);

		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(1868, 1);
		try
		{
			// EcmaScript.g:1873:2: ( BREAK (lb= Identifier )? semic )
			DebugEnterAlt(1);
			// EcmaScript.g:1874:9: BREAK (lb= Identifier )? semic
			{
			DebugLocation(1874, 9);
			Match(input,BREAK,Follow._BREAK_in_breakStatement9086); 
			DebugLocation(1875, 9);

						if (input.LA(1) == Identifier)
							PromoteEol();
					
			DebugLocation(1879, 9);
			// EcmaScript.g:1879:9: (lb= Identifier )?
			int alt79=2;
			try { DebugEnterSubRule(79);
			try { DebugEnterDecision(79, false);
			int LA79_0 = input.LA(1);

			if ((LA79_0==Identifier))
			{
				alt79 = 1;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1880:13: lb= Identifier
				{
				DebugLocation(1880, 15);
				lb=(IToken)Match(input,Identifier,Follow._Identifier_in_breakStatement9122); 
				DebugLocation(1880, 27);
				 label = lb.Text; 

				}
				break;

			}
			} finally { DebugExitSubRule(79); }

			DebugLocation(1882, 9);
			PushFollow(Follow._semic_in_breakStatement9145);
			semic();
			PopFollow();

			DebugLocation(1883, 9);
			 value = _builder.BuildBreak(label, GetLocation(start, input.LT(-1))); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("breakStatement", 71);
			LeaveRule("breakStatement", 71);
			LeaveRule_breakStatement();
		}
		DebugLocation(1884, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return value;

	}
	// $ANTLR end "breakStatement"


	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();

	// $ANTLR start "returnStatement"
	// EcmaScript.g:1904:1: returnStatement returns [ReturnSyntax value] : RETURN (expr= expression )? semic ;
	[GrammarRule("returnStatement")]
	private ReturnSyntax returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 72);
		TraceIn("returnStatement", 72);
		ReturnSyntax value = default(ReturnSyntax);

		ExpressionSyntax expr = default(ExpressionSyntax);


		    ExpressionSyntax returnExpression = null;
		    var start = input.LT(1);

		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(1904, 1);
		try
		{
			// EcmaScript.g:1909:2: ( RETURN (expr= expression )? semic )
			DebugEnterAlt(1);
			// EcmaScript.g:1910:9: RETURN (expr= expression )? semic
			{
			DebugLocation(1910, 9);
			Match(input,RETURN,Follow._RETURN_in_returnStatement9190); 
			DebugLocation(1911, 9);
			 PromoteEol(); 
			DebugLocation(1912, 9);
			// EcmaScript.g:1912:9: (expr= expression )?
			int alt80=2;
			try { DebugEnterSubRule(80);
			try { DebugEnterDecision(80, false);
			int LA80_0 = input.LA(1);

			if ((LA80_0==ADD||LA80_0==DEC||LA80_0==DELETE||LA80_0==DecimalLiteral||LA80_0==FALSE||LA80_0==FUNCTION||LA80_0==HexIntegerLiteral||LA80_0==INC||LA80_0==INV||LA80_0==Identifier||(LA80_0>=LBRACE && LA80_0<=LBRACK)||LA80_0==LPAREN||(LA80_0>=NEW && LA80_0<=NOT)||LA80_0==NULL||LA80_0==OctalIntegerLiteral||LA80_0==RegularExpressionLiteral||LA80_0==SUB||LA80_0==StringLiteral||LA80_0==THIS||LA80_0==TRUE||LA80_0==TYPEOF||LA80_0==VOID))
			{
				alt80 = 1;
			}
			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:1913:13: expr= expression
				{
				DebugLocation(1913, 17);
				PushFollow(Follow._expression_in_returnStatement9226);
				expr=expression();
				PopFollow();

				DebugLocation(1914, 13);
				 returnExpression = expr; 

				}
				break;

			}
			} finally { DebugExitSubRule(80); }

			DebugLocation(1916, 9);
			PushFollow(Follow._semic_in_returnStatement9261);
			semic();
			PopFollow();

			DebugLocation(1917, 9);
			 value = _builder.BuildReturn(returnExpression, GetLocation(start, input.LT(-1))); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("returnStatement", 72);
			LeaveRule("returnStatement", 72);
			LeaveRule_returnStatement();
		}
		DebugLocation(1918, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return value;

	}
	// $ANTLR end "returnStatement"


	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();

	// $ANTLR start "withStatement"
	// EcmaScript.g:1924:1: withStatement returns [SyntaxNode value] : WITH LPAREN exp= expression RPAREN smt= statement ;
	[GrammarRule("withStatement")]
	private SyntaxNode withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 73);
		TraceIn("withStatement", 73);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax exp = default(ExpressionSyntax);
		SyntaxNode smt = default(SyntaxNode);


		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(1924, 1);
		try
		{
			// EcmaScript.g:1929:2: ( WITH LPAREN exp= expression RPAREN smt= statement )
			DebugEnterAlt(1);
			// EcmaScript.g:1930:9: WITH LPAREN exp= expression RPAREN smt= statement
			{
			DebugLocation(1930, 9);
			Match(input,WITH,Follow._WITH_in_withStatement9304); 
			DebugLocation(1930, 14);
			Match(input,LPAREN,Follow._LPAREN_in_withStatement9306); 
			DebugLocation(1930, 24);
			PushFollow(Follow._expression_in_withStatement9310);
			exp=expression();
			PopFollow();

			DebugLocation(1930, 36);
			Match(input,RPAREN,Follow._RPAREN_in_withStatement9312); 
			DebugLocation(1931, 9);

						end = input.LT(-1);
						_builder.EnterWith();
					
			DebugLocation(1935, 12);
			PushFollow(Follow._statement_in_withStatement9334);
			smt=statement();
			PopFollow();

			DebugLocation(1936, 9);
			 value = _builder.ExitWith(exp, smt, GetLocation(start, end)); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("withStatement", 73);
			LeaveRule("withStatement", 73);
			LeaveRule_withStatement();
		}
		DebugLocation(1937, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return value;

	}
	// $ANTLR end "withStatement"


	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();

	// $ANTLR start "switchStatement"
	// EcmaScript.g:1943:1: switchStatement returns [SyntaxNode value] : SWITCH LPAREN e= expression RPAREN LBRACE ({...}? =>def= defaultClause |cc= caseClause )* RBRACE ;
	[GrammarRule("switchStatement")]
	private SyntaxNode switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 74);
		TraceIn("switchStatement", 74);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax e = default(ExpressionSyntax);
		SwitchCase def = default(SwitchCase);
		SwitchCase cc = default(SwitchCase);


		    bool hadDefault = false;
		    var cases = new ReadOnlyArray<SwitchCase>.Builder();
		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(1943, 1);
		try
		{
			// EcmaScript.g:1950:2: ( SWITCH LPAREN e= expression RPAREN LBRACE ({...}? =>def= defaultClause |cc= caseClause )* RBRACE )
			DebugEnterAlt(1);
			// EcmaScript.g:1951:9: SWITCH LPAREN e= expression RPAREN LBRACE ({...}? =>def= defaultClause |cc= caseClause )* RBRACE
			{
			DebugLocation(1951, 9);
			Match(input,SWITCH,Follow._SWITCH_in_switchStatement9377); 
			DebugLocation(1951, 16);
			Match(input,LPAREN,Follow._LPAREN_in_switchStatement9379); 
			DebugLocation(1951, 24);
			PushFollow(Follow._expression_in_switchStatement9383);
			e=expression();
			PopFollow();

			DebugLocation(1951, 36);
			Match(input,RPAREN,Follow._RPAREN_in_switchStatement9385); 
			DebugLocation(1952, 9);
			 end = input.LT(-1); 
			DebugLocation(1953, 9);
			Match(input,LBRACE,Follow._LBRACE_in_switchStatement9405); 
			DebugLocation(1954, 9);
			// EcmaScript.g:1954:9: ({...}? =>def= defaultClause |cc= caseClause )*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=3;
				try { DebugEnterDecision(81, false);
				int LA81_0 = input.LA(1);

				if ((LA81_0==DEFAULT) && (( !hadDefault )))
				{
					alt81 = 1;
				}
				else if ((LA81_0==CASE))
				{
					alt81 = 2;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1955:13: {...}? =>def= defaultClause
					{
					DebugLocation(1955, 13);
					if (!(( !hadDefault )))
					{
						throw new FailedPredicateException(input, "switchStatement", " !hadDefault ");
					}
					DebugLocation(1956, 16);
					PushFollow(Follow._defaultClause_in_switchStatement9446);
					def=defaultClause();
					PopFollow();

					DebugLocation(1957, 13);
					 hadDefault = true; cases.Add(def); 

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// EcmaScript.g:1959:13: cc= caseClause
					{
					DebugLocation(1959, 15);
					PushFollow(Follow._caseClause_in_switchStatement9486);
					cc=caseClause();
					PopFollow();

					DebugLocation(1960, 13);
					 cases.Add(cc); 

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }

			DebugLocation(1962, 9);
			Match(input,RBRACE,Follow._RBRACE_in_switchStatement9521); 
			DebugLocation(1963, 9);
			 value = _builder.BuildSwitch(e, cases.ToReadOnly(), GetLocation(start, end)); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("switchStatement", 74);
			LeaveRule("switchStatement", 74);
			LeaveRule_switchStatement();
		}
		DebugLocation(1964, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return value;

	}
	// $ANTLR end "switchStatement"


	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();

	// $ANTLR start "caseClause"
	// EcmaScript.g:1966:1: caseClause returns [SwitchCase value] : CASE e= expression COLON (st= statement )* ;
	[GrammarRule("caseClause")]
	private SwitchCase caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 75);
		TraceIn("caseClause", 75);
		SwitchCase value = default(SwitchCase);

		ExpressionSyntax e = default(ExpressionSyntax);
		SyntaxNode st = default(SyntaxNode);


		    var statements = new ReadOnlyArray<SyntaxNode>.Builder();
		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(1966, 1);
		try
		{
			// EcmaScript.g:1972:2: ( CASE e= expression COLON (st= statement )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1973:9: CASE e= expression COLON (st= statement )*
			{
			DebugLocation(1973, 9);
			Match(input,CASE,Follow._CASE_in_caseClause9559); 
			DebugLocation(1973, 15);
			PushFollow(Follow._expression_in_caseClause9563);
			e=expression();
			PopFollow();

			DebugLocation(1973, 27);
			Match(input,COLON,Follow._COLON_in_caseClause9565); 
			DebugLocation(1974, 9);
			 end = input.LT(-1); 
			DebugLocation(1975, 9);
			// EcmaScript.g:1975:9: (st= statement )*
			try { DebugEnterSubRule(82);
			while (true)
			{
				int alt82=2;
				try { DebugEnterDecision(82, false);
				int LA82_0 = input.LA(1);

				if ((LA82_0==ADD||LA82_0==BREAK||LA82_0==CONTINUE||LA82_0==DEC||LA82_0==DELETE||LA82_0==DO||LA82_0==DecimalLiteral||LA82_0==FALSE||LA82_0==FOR||LA82_0==FUNCTION||(LA82_0>=HexIntegerLiteral && LA82_0<=IF)||LA82_0==INC||LA82_0==INV||LA82_0==Identifier||(LA82_0>=LBRACE && LA82_0<=LBRACK)||LA82_0==LPAREN||(LA82_0>=NEW && LA82_0<=NOT)||LA82_0==NULL||LA82_0==OctalIntegerLiteral||LA82_0==RETURN||LA82_0==RegularExpressionLiteral||LA82_0==SEMIC||LA82_0==SUB||LA82_0==SWITCH||LA82_0==StringLiteral||(LA82_0>=THIS && LA82_0<=THROW)||(LA82_0>=TRUE && LA82_0<=TYPEOF)||(LA82_0>=VAR && LA82_0<=VOID)||(LA82_0>=WHILE && LA82_0<=WITH)))
				{
					alt82 = 1;
				}


				} finally { DebugExitDecision(82); }
				switch ( alt82 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1976:13: st= statement
					{
					DebugLocation(1976, 15);
					PushFollow(Follow._statement_in_caseClause9601);
					st=statement();
					PopFollow();

					DebugLocation(1977, 13);
					 statements.Add(st); 

					}
					break;

				default:
					goto loop82;
				}
			}

			loop82:
				;

			} finally { DebugExitSubRule(82); }

			DebugLocation(1979, 9);

			            value = _builder.BuildSwitchCase(
			                e,
			                _builder.BuildBlock(statements.ToReadOnly()),
			                GetLocation(start, end)
			            );
			        

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("caseClause", 75);
			LeaveRule("caseClause", 75);
			LeaveRule_caseClause();
		}
		DebugLocation(1986, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return value;

	}
	// $ANTLR end "caseClause"


	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();

	// $ANTLR start "defaultClause"
	// EcmaScript.g:1988:1: defaultClause returns [SwitchCase value] : DEFAULT COLON (st= statement )* ;
	[GrammarRule("defaultClause")]
	private SwitchCase defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 76);
		TraceIn("defaultClause", 76);
		SwitchCase value = default(SwitchCase);

		SyntaxNode st = default(SyntaxNode);


		    var statements = new ReadOnlyArray<SyntaxNode>.Builder();
		    var start = input.LT(1);
		    IToken end;

		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(1988, 1);
		try
		{
			// EcmaScript.g:1994:2: ( DEFAULT COLON (st= statement )* )
			DebugEnterAlt(1);
			// EcmaScript.g:1995:9: DEFAULT COLON (st= statement )*
			{
			DebugLocation(1995, 9);
			Match(input,DEFAULT,Follow._DEFAULT_in_defaultClause9665); 
			DebugLocation(1995, 17);
			Match(input,COLON,Follow._COLON_in_defaultClause9667); 
			DebugLocation(1996, 9);
			 end = input.LT(-1); 
			DebugLocation(1997, 9);
			// EcmaScript.g:1997:9: (st= statement )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_0 = input.LA(1);

				if ((LA83_0==ADD||LA83_0==BREAK||LA83_0==CONTINUE||LA83_0==DEC||LA83_0==DELETE||LA83_0==DO||LA83_0==DecimalLiteral||LA83_0==FALSE||LA83_0==FOR||LA83_0==FUNCTION||(LA83_0>=HexIntegerLiteral && LA83_0<=IF)||LA83_0==INC||LA83_0==INV||LA83_0==Identifier||(LA83_0>=LBRACE && LA83_0<=LBRACK)||LA83_0==LPAREN||(LA83_0>=NEW && LA83_0<=NOT)||LA83_0==NULL||LA83_0==OctalIntegerLiteral||LA83_0==RETURN||LA83_0==RegularExpressionLiteral||LA83_0==SEMIC||LA83_0==SUB||LA83_0==SWITCH||LA83_0==StringLiteral||(LA83_0>=THIS && LA83_0<=THROW)||(LA83_0>=TRUE && LA83_0<=TYPEOF)||(LA83_0>=VAR && LA83_0<=VOID)||(LA83_0>=WHILE && LA83_0<=WITH)))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:1998:13: st= statement
					{
					DebugLocation(1998, 15);
					PushFollow(Follow._statement_in_defaultClause9703);
					st=statement();
					PopFollow();

					DebugLocation(1999, 13);
					 statements.Add(st); 

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }

			DebugLocation(2001, 9);

			            value = _builder.BuildSwitchCase(
			                null,
			                new BlockSyntax(statements.ToReadOnly()),
			                GetLocation(start, end)
			            );
			        

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("defaultClause", 76);
			LeaveRule("defaultClause", 76);
			LeaveRule_defaultClause();
		}
		DebugLocation(2008, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return value;

	}
	// $ANTLR end "defaultClause"


	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();

	// $ANTLR start "labelledStatement"
	// EcmaScript.g:2014:1: labelledStatement returns [SyntaxNode value] : lb= Identifier COLON st= statement ;
	[GrammarRule("labelledStatement")]
	private SyntaxNode labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 77);
		TraceIn("labelledStatement", 77);
		SyntaxNode value = default(SyntaxNode);

		IToken lb = default(IToken);
		SyntaxNode st = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(2014, 1);
		try
		{
			// EcmaScript.g:2015:2: (lb= Identifier COLON st= statement )
			DebugEnterAlt(1);
			// EcmaScript.g:2016:9: lb= Identifier COLON st= statement
			{
			DebugLocation(2016, 11);
			lb=(IToken)Match(input,Identifier,Follow._Identifier_in_labelledStatement9769); 
			DebugLocation(2016, 23);
			Match(input,COLON,Follow._COLON_in_labelledStatement9771); 
			DebugLocation(2016, 31);
			PushFollow(Follow._statement_in_labelledStatement9775);
			st=statement();
			PopFollow();

			DebugLocation(2017, 9);
			 value = _builder.BuildLabel(lb.Text, st); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("labelledStatement", 77);
			LeaveRule("labelledStatement", 77);
			LeaveRule_labelledStatement();
		}
		DebugLocation(2018, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return value;

	}
	// $ANTLR end "labelledStatement"


	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();

	// $ANTLR start "throwStatement"
	// EcmaScript.g:2041:1: throwStatement returns [SyntaxNode value] : THROW exp= expression semic ;
	[GrammarRule("throwStatement")]
	private SyntaxNode throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 78);
		TraceIn("throwStatement", 78);
		SyntaxNode value = default(SyntaxNode);

		ExpressionSyntax exp = default(ExpressionSyntax);


		    var start = input.LT(1);

		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(2041, 1);
		try
		{
			// EcmaScript.g:2045:2: ( THROW exp= expression semic )
			DebugEnterAlt(1);
			// EcmaScript.g:2046:9: THROW exp= expression semic
			{
			DebugLocation(2046, 9);
			Match(input,THROW,Follow._THROW_in_throwStatement9820); 
			DebugLocation(2047, 3);
			 PromoteEol(); 
			DebugLocation(2048, 6);
			PushFollow(Follow._expression_in_throwStatement9830);
			exp=expression();
			PopFollow();

			DebugLocation(2048, 18);
			PushFollow(Follow._semic_in_throwStatement9832);
			semic();
			PopFollow();

			DebugLocation(2049, 9);
			 value = _builder.BuildThrow(exp, GetLocation(start, input.LT(-1))); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("throwStatement", 78);
			LeaveRule("throwStatement", 78);
			LeaveRule_throwStatement();
		}
		DebugLocation(2050, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return value;

	}
	// $ANTLR end "throwStatement"


	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();

	// $ANTLR start "tryStatement"
	// EcmaScript.g:2056:1: tryStatement returns [TrySyntax value] : TRY b= block (c= catchClause (first= finallyClause )? |last= finallyClause ) ;
	[GrammarRule("tryStatement")]
	private TrySyntax tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 79);
		TraceIn("tryStatement", 79);
		TrySyntax value = default(TrySyntax);

		BlockSyntax b = default(BlockSyntax);
		CatchClause c = default(CatchClause);
		FinallyClause first = default(FinallyClause);
		FinallyClause last = default(FinallyClause);


		    CatchClause @catch = null;
		    FinallyClause @finally = null;

		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(2056, 1);
		try
		{
			// EcmaScript.g:2061:2: ( TRY b= block (c= catchClause (first= finallyClause )? |last= finallyClause ) )
			DebugEnterAlt(1);
			// EcmaScript.g:2062:9: TRY b= block (c= catchClause (first= finallyClause )? |last= finallyClause )
			{
			DebugLocation(2062, 9);
			Match(input,TRY,Follow._TRY_in_tryStatement9874); 
			DebugLocation(2062, 14);
			PushFollow(Follow._block_in_tryStatement9878);
			b=block();
			PopFollow();

			DebugLocation(2063, 9);
			// EcmaScript.g:2063:9: (c= catchClause (first= finallyClause )? |last= finallyClause )
			int alt85=2;
			try { DebugEnterSubRule(85);
			try { DebugEnterDecision(85, false);
			int LA85_0 = input.LA(1);

			if ((LA85_0==CATCH))
			{
				alt85 = 1;
			}
			else if ((LA85_0==FINALLY))
			{
				alt85 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 85, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(85); }
			switch (alt85)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:2064:13: c= catchClause (first= finallyClause )?
				{
				DebugLocation(2064, 14);
				PushFollow(Follow._catchClause_in_tryStatement9904);
				c=catchClause();
				PopFollow();

				DebugLocation(2065, 13);
				 @catch = c; 
				DebugLocation(2066, 13);
				// EcmaScript.g:2066:13: (first= finallyClause )?
				int alt84=2;
				try { DebugEnterSubRule(84);
				try { DebugEnterDecision(84, false);
				int LA84_0 = input.LA(1);

				if ((LA84_0==FINALLY))
				{
					alt84 = 1;
				}
				} finally { DebugExitDecision(84); }
				switch (alt84)
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:2067:17: first= finallyClause
					{
					DebugLocation(2067, 22);
					PushFollow(Follow._finallyClause_in_tryStatement9952);
					first=finallyClause();
					PopFollow();

					DebugLocation(2068, 17);
					 @finally = first; 

					}
					break;

				}
				} finally { DebugExitSubRule(84); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:2071:13: last= finallyClause
				{
				DebugLocation(2071, 17);
				PushFollow(Follow._finallyClause_in_tryStatement10011);
				last=finallyClause();
				PopFollow();

				DebugLocation(2072, 13);
				 @finally = last; 

				}
				break;

			}
			} finally { DebugExitSubRule(85); }

			DebugLocation(2074, 9);
			 value = _builder.BuildTry(b, @catch, @finally); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("tryStatement", 79);
			LeaveRule("tryStatement", 79);
			LeaveRule_tryStatement();
		}
		DebugLocation(2075, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return value;

	}
	// $ANTLR end "tryStatement"


	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();

	// $ANTLR start "catchClause"
	// EcmaScript.g:2077:1: catchClause returns [CatchClause value] : CATCH LPAREN id= Identifier RPAREN b= block ;
	[GrammarRule("catchClause")]
	private CatchClause catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 80);
		TraceIn("catchClause", 80);
		CatchClause value = default(CatchClause);

		IToken id = default(IToken);
		BlockSyntax b = default(BlockSyntax);

		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(2077, 1);
		try
		{
			// EcmaScript.g:2078:2: ( CATCH LPAREN id= Identifier RPAREN b= block )
			DebugEnterAlt(1);
			// EcmaScript.g:2079:9: CATCH LPAREN id= Identifier RPAREN b= block
			{
			DebugLocation(2079, 9);
			Match(input,CATCH,Follow._CATCH_in_catchClause10069); 
			DebugLocation(2079, 15);
			Match(input,LPAREN,Follow._LPAREN_in_catchClause10071); 
			DebugLocation(2079, 24);
			id=(IToken)Match(input,Identifier,Follow._Identifier_in_catchClause10075); 
			DebugLocation(2079, 36);
			Match(input,RPAREN,Follow._RPAREN_in_catchClause10077); 
			DebugLocation(2080, 3);
			 _builder.EnterCatch((id!=null?id.Text:null)); 
			DebugLocation(2081, 4);
			PushFollow(Follow._block_in_catchClause10087);
			b=block();
			PopFollow();

			DebugLocation(2082, 9);
			 value = _builder.ExitCatch(b); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("catchClause", 80);
			LeaveRule("catchClause", 80);
			LeaveRule_catchClause();
		}
		DebugLocation(2083, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return value;

	}
	// $ANTLR end "catchClause"


	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();

	// $ANTLR start "finallyClause"
	// EcmaScript.g:2085:1: finallyClause returns [FinallyClause value] : FINALLY b= block ;
	[GrammarRule("finallyClause")]
	private FinallyClause finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 81);
		TraceIn("finallyClause", 81);
		FinallyClause value = default(FinallyClause);

		BlockSyntax b = default(BlockSyntax);

		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(2085, 1);
		try
		{
			// EcmaScript.g:2086:2: ( FINALLY b= block )
			DebugEnterAlt(1);
			// EcmaScript.g:2087:9: FINALLY b= block
			{
			DebugLocation(2087, 9);
			Match(input,FINALLY,Follow._FINALLY_in_finallyClause10121); 
			DebugLocation(2087, 18);
			PushFollow(Follow._block_in_finallyClause10125);
			b=block();
			PopFollow();

			DebugLocation(2088, 9);
			 value = _builder.BuildFinallyClause(b); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("finallyClause", 81);
			LeaveRule("finallyClause", 81);
			LeaveRule_finallyClause();
		}
		DebugLocation(2089, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return value;

	}
	// $ANTLR end "finallyClause"


	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();

	// $ANTLR start "functionDeclaration"
	// EcmaScript.g:2101:1: functionDeclaration returns [SyntaxNode value] : FUNCTION id= Identifier parms= formalParameterList functionBody ;
	[GrammarRule("functionDeclaration")]
	private SyntaxNode functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 82);
		TraceIn("functionDeclaration", 82);
		SyntaxNode value = default(SyntaxNode);

		IToken id = default(IToken);
		ReadOnlyArray<string> parms = default(ReadOnlyArray<string>);


		    var start = input.LT(1);
		    string name;
		    ReadOnlyArray<string> parameters;
		    BodySyntax body;

		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(2101, 1);
		try
		{
			// EcmaScript.g:2118:2: ( FUNCTION id= Identifier parms= formalParameterList functionBody )
			DebugEnterAlt(1);
			// EcmaScript.g:2119:9: FUNCTION id= Identifier parms= formalParameterList functionBody
			{
			DebugLocation(2119, 9);
			Match(input,FUNCTION,Follow._FUNCTION_in_functionDeclaration10178); 
			DebugLocation(2119, 20);
			id=(IToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration10182); 
			DebugLocation(2120, 9);
			 name = id.Text; 
			DebugLocation(2121, 8);
			PushFollow(Follow._formalParameterList_in_functionDeclaration10199);
			parms=formalParameterList();
			PopFollow();

			DebugLocation(2122, 9);

						parameters = parms;
						_builder.EnterFunctionBody(parameters);
					
			DebugLocation(2126, 3);
			PushFollow(Follow._functionBody_in_functionDeclaration10213);
			functionBody();
			PopFollow();

			DebugLocation(2127, 9);
			 body = _builder.ExitBody(); 

			}


			    _builder.AddDeclaredFunction(_builder.BuildFunction(
			        name,
			        parameters,
			        body,
			        GetLocation(start, input.LT(-1))
			    ));

			    value = _builder.BuildEmpty();

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionDeclaration", 82);
			LeaveRule("functionDeclaration", 82);
			LeaveRule_functionDeclaration();
		}
		DebugLocation(2128, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return value;

	}
	// $ANTLR end "functionDeclaration"


	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();

	// $ANTLR start "functionExpression"
	// EcmaScript.g:2130:1: functionExpression returns [FunctionSyntax value] : FUNCTION (id= Identifier )? fpl= formalParameterList functionBody ;
	[GrammarRule("functionExpression")]
	private FunctionSyntax functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 83);
		TraceIn("functionExpression", 83);
		FunctionSyntax value = default(FunctionSyntax);

		IToken id = default(IToken);
		ReadOnlyArray<string> fpl = default(ReadOnlyArray<string>);


		    var start = input.LT(1);
		    string name = null;
		    ReadOnlyArray<string> parameters;
		    BodySyntax body;

		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(2130, 1);
		try
		{
			// EcmaScript.g:2145:2: ( FUNCTION (id= Identifier )? fpl= formalParameterList functionBody )
			DebugEnterAlt(1);
			// EcmaScript.g:2146:9: FUNCTION (id= Identifier )? fpl= formalParameterList functionBody
			{
			DebugLocation(2146, 9);
			Match(input,FUNCTION,Follow._FUNCTION_in_functionExpression10256); 
			DebugLocation(2147, 9);
			// EcmaScript.g:2147:9: (id= Identifier )?
			int alt86=2;
			try { DebugEnterSubRule(86);
			try { DebugEnterDecision(86, false);
			int LA86_0 = input.LA(1);

			if ((LA86_0==Identifier))
			{
				alt86 = 1;
			}
			} finally { DebugExitDecision(86); }
			switch (alt86)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:2148:13: id= Identifier
				{
				DebugLocation(2148, 15);
				id=(IToken)Match(input,Identifier,Follow._Identifier_in_functionExpression10282); 
				DebugLocation(2149, 13);
				 name = id.Text; 

				}
				break;

			}
			} finally { DebugExitSubRule(86); }

			DebugLocation(2151, 12);
			PushFollow(Follow._formalParameterList_in_functionExpression10319);
			fpl=formalParameterList();
			PopFollow();

			DebugLocation(2152, 9);

						parameters = fpl;
						_builder.EnterFunctionBody(parameters);
					
			DebugLocation(2156, 9);
			PushFollow(Follow._functionBody_in_functionExpression10339);
			functionBody();
			PopFollow();

			DebugLocation(2157, 9);
			 body = _builder.ExitBody(); 

			}


				value = _builder.BuildFunction(
			        name,
			        parameters,
			        body,
			        GetLocation(start, input.LT(-1))
			    );

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionExpression", 83);
			LeaveRule("functionExpression", 83);
			LeaveRule_functionExpression();
		}
		DebugLocation(2158, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return value;

	}
	// $ANTLR end "functionExpression"


	partial void EnterRule_formalParameterList();
	partial void LeaveRule_formalParameterList();

	// $ANTLR start "formalParameterList"
	// EcmaScript.g:2160:1: formalParameterList returns [ReadOnlyArray<string> value] : LPAREN (first= Identifier ( COMMA follow= Identifier )* )? RPAREN ;
	[GrammarRule("formalParameterList")]
	private ReadOnlyArray<string> formalParameterList()
	{
		EnterRule_formalParameterList();
		EnterRule("formalParameterList", 84);
		TraceIn("formalParameterList", 84);
		ReadOnlyArray<string> value = default(ReadOnlyArray<string>);

		IToken first = default(IToken);
		IToken follow = default(IToken);


		    var identifiers = new ReadOnlyArray<string>.Builder();

		try { DebugEnterRule(GrammarFileName, "formalParameterList");
		DebugLocation(2160, 1);
		try
		{
			// EcmaScript.g:2167:2: ( LPAREN (first= Identifier ( COMMA follow= Identifier )* )? RPAREN )
			DebugEnterAlt(1);
			// EcmaScript.g:2168:9: LPAREN (first= Identifier ( COMMA follow= Identifier )* )? RPAREN
			{
			DebugLocation(2168, 9);
			Match(input,LPAREN,Follow._LPAREN_in_formalParameterList10382); 
			DebugLocation(2169, 9);
			// EcmaScript.g:2169:9: (first= Identifier ( COMMA follow= Identifier )* )?
			int alt88=2;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, false);
			int LA88_0 = input.LA(1);

			if ((LA88_0==Identifier))
			{
				alt88 = 1;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:2170:13: first= Identifier ( COMMA follow= Identifier )*
				{
				DebugLocation(2170, 18);
				first=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList10408); 
				DebugLocation(2171, 13);
				 identifiers.Add((first!=null?first.Text:null)); 
				DebugLocation(2172, 13);
				// EcmaScript.g:2172:13: ( COMMA follow= Identifier )*
				try { DebugEnterSubRule(87);
				while (true)
				{
					int alt87=2;
					try { DebugEnterDecision(87, false);
					int LA87_0 = input.LA(1);

					if ((LA87_0==COMMA))
					{
						alt87 = 1;
					}


					} finally { DebugExitDecision(87); }
					switch ( alt87 )
					{
					case 1:
						DebugEnterAlt(1);
						// EcmaScript.g:2173:17: COMMA follow= Identifier
						{
						DebugLocation(2173, 17);
						Match(input,COMMA,Follow._COMMA_in_formalParameterList10454); 
						DebugLocation(2173, 29);
						follow=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList10458); 
						DebugLocation(2174, 17);
						 identifiers.Add((follow!=null?follow.Text:null)); 

						}
						break;

					default:
						goto loop87;
					}
				}

				loop87:
					;

				} finally { DebugExitSubRule(87); }


				}
				break;

			}
			} finally { DebugExitSubRule(88); }

			DebugLocation(2177, 9);
			Match(input,RPAREN,Follow._RPAREN_in_formalParameterList10512); 

			}


				value = identifiers.ToReadOnly();

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("formalParameterList", 84);
			LeaveRule("formalParameterList", 84);
			LeaveRule_formalParameterList();
		}
		DebugLocation(2178, 1);
		} finally { DebugExitRule(GrammarFileName, "formalParameterList"); }
		return value;

	}
	// $ANTLR end "formalParameterList"


	partial void EnterRule_functionBody();
	partial void LeaveRule_functionBody();

	// $ANTLR start "functionBody"
	// EcmaScript.g:2180:1: functionBody : lb= LBRACE (se= sourceElement )* RBRACE ;
	[GrammarRule("functionBody")]
	private void functionBody()
	{
		EnterRule_functionBody();
		EnterRule("functionBody", 85);
		TraceIn("functionBody", 85);
		IToken lb = default(IToken);
		SyntaxNode se = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "functionBody");
		DebugLocation(2180, 1);
		try
		{
			// EcmaScript.g:2181:2: (lb= LBRACE (se= sourceElement )* RBRACE )
			DebugEnterAlt(1);
			// EcmaScript.g:2182:9: lb= LBRACE (se= sourceElement )* RBRACE
			{
			DebugLocation(2182, 11);
			lb=(IToken)Match(input,LBRACE,Follow._LBRACE_in_functionBody10533); 
			DebugLocation(2183, 9);
			// EcmaScript.g:2183:9: (se= sourceElement )*
			try { DebugEnterSubRule(89);
			while (true)
			{
				int alt89=2;
				try { DebugEnterDecision(89, false);
				int LA89_0 = input.LA(1);

				if ((LA89_0==ADD||LA89_0==BREAK||LA89_0==CONTINUE||LA89_0==DEC||LA89_0==DELETE||LA89_0==DO||LA89_0==DecimalLiteral||LA89_0==FALSE||LA89_0==FOR||LA89_0==FUNCTION||(LA89_0>=HexIntegerLiteral && LA89_0<=IF)||LA89_0==INC||LA89_0==INV||LA89_0==Identifier||(LA89_0>=LBRACE && LA89_0<=LBRACK)||LA89_0==LPAREN||(LA89_0>=NEW && LA89_0<=NOT)||LA89_0==NULL||LA89_0==OctalIntegerLiteral||LA89_0==RETURN||LA89_0==RegularExpressionLiteral||LA89_0==SEMIC||LA89_0==SUB||LA89_0==SWITCH||LA89_0==StringLiteral||(LA89_0>=THIS && LA89_0<=THROW)||(LA89_0>=TRUE && LA89_0<=TYPEOF)||(LA89_0>=VAR && LA89_0<=VOID)||(LA89_0>=WHILE && LA89_0<=WITH)))
				{
					alt89 = 1;
				}


				} finally { DebugExitDecision(89); }
				switch ( alt89 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:2184:13: se= sourceElement
					{
					DebugLocation(2184, 15);
					PushFollow(Follow._sourceElement_in_functionBody10559);
					se=sourceElement();
					PopFollow();

					DebugLocation(2185, 13);
					 _builder.AddStatement(se); 

					}
					break;

				default:
					goto loop89;
				}
			}

			loop89:
				;

			} finally { DebugExitSubRule(89); }

			DebugLocation(2187, 9);
			Match(input,RBRACE,Follow._RBRACE_in_functionBody10594); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("functionBody", 85);
			LeaveRule("functionBody", 85);
			LeaveRule_functionBody();
		}
		DebugLocation(2188, 1);
		} finally { DebugExitRule(GrammarFileName, "functionBody"); }
		return;

	}
	// $ANTLR end "functionBody"


	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// EcmaScript.g:2194:1: program returns [ProgramSyntax value] : (follow= sourceElement )* ;
	[GrammarRule("program")]
	private ProgramSyntax program()
	{
		EnterRule_program();
		EnterRule("program", 86);
		TraceIn("program", 86);
		ProgramSyntax value = default(ProgramSyntax);

		SyntaxNode follow = default(SyntaxNode);


			_builder.EnterProgramBody();

		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(2194, 1);
		try
		{
			// EcmaScript.g:2198:2: ( (follow= sourceElement )* )
			DebugEnterAlt(1);
			// EcmaScript.g:2199:9: (follow= sourceElement )*
			{
			DebugLocation(2199, 9);
			// EcmaScript.g:2199:9: (follow= sourceElement )*
			try { DebugEnterSubRule(90);
			while (true)
			{
				int alt90=2;
				try { DebugEnterDecision(90, false);
				int LA90_0 = input.LA(1);

				if ((LA90_0==ADD||LA90_0==BREAK||LA90_0==CONTINUE||LA90_0==DEC||LA90_0==DELETE||LA90_0==DO||LA90_0==DecimalLiteral||LA90_0==FALSE||LA90_0==FOR||LA90_0==FUNCTION||(LA90_0>=HexIntegerLiteral && LA90_0<=IF)||LA90_0==INC||LA90_0==INV||LA90_0==Identifier||(LA90_0>=LBRACE && LA90_0<=LBRACK)||LA90_0==LPAREN||(LA90_0>=NEW && LA90_0<=NOT)||LA90_0==NULL||LA90_0==OctalIntegerLiteral||LA90_0==RETURN||LA90_0==RegularExpressionLiteral||LA90_0==SEMIC||LA90_0==SUB||LA90_0==SWITCH||LA90_0==StringLiteral||(LA90_0>=THIS && LA90_0<=THROW)||(LA90_0>=TRUE && LA90_0<=TYPEOF)||(LA90_0>=VAR && LA90_0<=VOID)||(LA90_0>=WHILE && LA90_0<=WITH)))
				{
					alt90 = 1;
				}


				} finally { DebugExitDecision(90); }
				switch ( alt90 )
				{
				case 1:
					DebugEnterAlt(1);
					// EcmaScript.g:2200:13: follow= sourceElement
					{
					DebugLocation(2200, 19);
					PushFollow(Follow._sourceElement_in_program10642);
					follow=sourceElement();
					PopFollow();

					DebugLocation(2201, 13);
					 _builder.AddStatement(follow); 

					}
					break;

				default:
					goto loop90;
				}
			}

			loop90:
				;

			} finally { DebugExitSubRule(90); }

			DebugLocation(2203, 9);
			 value = _builder.BuildProgram(_builder.ExitBody()); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 86);
			LeaveRule("program", 86);
			LeaveRule_program();
		}
		DebugLocation(2204, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return value;

	}
	// $ANTLR end "program"


	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();

	// $ANTLR start "sourceElement"
	// EcmaScript.g:2213:1: sourceElement returns [SyntaxNode value] options {k=1; } : ({...}?func= functionDeclaration |stat= statement );
	[GrammarRule("sourceElement")]
	private SyntaxNode sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 87);
		TraceIn("sourceElement", 87);
		SyntaxNode value = default(SyntaxNode);

		SyntaxNode func = default(SyntaxNode);
		SyntaxNode stat = default(SyntaxNode);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(2213, 1);
		try
		{
			// EcmaScript.g:2219:2: ({...}?func= functionDeclaration |stat= statement )
			int alt91=2;
			try { DebugEnterDecision(91, false);
			try
			{
				alt91 = dfa91.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(91); }
			switch (alt91)
			{
			case 1:
				DebugEnterAlt(1);
				// EcmaScript.g:2220:3: {...}?func= functionDeclaration
				{
				DebugLocation(2220, 3);
				if (!(( input.LA(1) == FUNCTION )))
				{
					throw new FailedPredicateException(input, "sourceElement", " input.LA(1) == FUNCTION ");
				}
				DebugLocation(2221, 7);
				PushFollow(Follow._functionDeclaration_in_sourceElement10716);
				func=functionDeclaration();
				PopFollow();

				DebugLocation(2221, 28);
				 value = func; 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// EcmaScript.g:2223:3: stat= statement
				{
				DebugLocation(2223, 7);
				PushFollow(Follow._statement_in_sourceElement10727);
				stat=statement();
				PopFollow();

				DebugLocation(2224, 3);
				 value = stat; 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("sourceElement", 87);
			LeaveRule("sourceElement", 87);
			LeaveRule_sourceElement();
		}
		DebugLocation(2225, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return value;

	}
	// $ANTLR end "sourceElement"
	#endregion Rules


	#region DFA
	private DFA59 dfa59;
	private DFA60 dfa60;
	private DFA91 dfa91;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa59 = new DFA59( this, SpecialStateTransition59 );
		dfa60 = new DFA60( this );
		dfa91 = new DFA91( this, SpecialStateTransition91 );
	}

	private class DFA59 : DFA
	{
		private const string DFA59_eotS =
			"\x28\xFFFF";
		private const string DFA59_eofS =
			"\x28\xFFFF";
		private const string DFA59_minS =
			"\x1\x5\x2\x0\x25\xFFFF";
		private const string DFA59_maxS =
			"\x1\xA7\x2\x0\x25\xFFFF";
		private const string DFA59_acceptS =
			"\x3\xFFFF\x1\x3\x22\xFFFF\x1\x1\x1\x2";
		private const string DFA59_specialS =
			"\x1\xFFFF\x1\x0\x1\x1\x25\xFFFF}>";
		private static readonly string[] DFA59_transitionS =
			{
				"\x1\x3\x8\xFFFF\x1\x3\xE\xFFFF\x1\x3\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\x2"+
				"\xFFFF\x1\x3\x5\xFFFF\x1\x3\x9\xFFFF\x1\x3\x4\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\x2\x5\xFFFF\x2\x3\x3\xFFFF\x1\x3\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\x5\xFFFF"+
				"\x1\x1\x1\x3\x3\xFFFF\x1\x3\xE\xFFFF\x2\x3\x1\xFFFF\x1\x3\x5\xFFFF\x1"+
				"\x3\xD\xFFFF\x1\x3\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\xA\xFFFF\x1\x3\x2\xFFFF"+
				"\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x2\x3\x2\xFFFF\x3\x3\x2\xFFFF\x2\x3\x2"+
				"\xFFFF\x2\x3",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA59_eot = DFA.UnpackEncodedString(DFA59_eotS);
		private static readonly short[] DFA59_eof = DFA.UnpackEncodedString(DFA59_eofS);
		private static readonly char[] DFA59_min = DFA.UnpackEncodedStringToUnsignedChars(DFA59_minS);
		private static readonly char[] DFA59_max = DFA.UnpackEncodedStringToUnsignedChars(DFA59_maxS);
		private static readonly short[] DFA59_accept = DFA.UnpackEncodedString(DFA59_acceptS);
		private static readonly short[] DFA59_special = DFA.UnpackEncodedString(DFA59_specialS);
		private static readonly short[][] DFA59_transition;

		static DFA59()
		{
			int numStates = DFA59_transitionS.Length;
			DFA59_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA59_transition[i] = DFA.UnpackEncodedString(DFA59_transitionS[i]);
			}
		}

		public DFA59( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 59;
			this.eot = DFA59_eot;
			this.eof = DFA59_eof;
			this.min = DFA59_min;
			this.max = DFA59_max;
			this.accept = DFA59_accept;
			this.special = DFA59_special;
			this.transition = DFA59_transition;
		}

		public override string Description { get { return "1478:1: statement returns [SyntaxNode value] options {k=1; } : ({...}?b= block |{...}?func= functionDeclaration |st= statementTail );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition59(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA59_1 = input.LA(1);


				int index59_1 = input.Index;
				input.Rewind();
				s = -1;
				if ((( input.LA(1) == LBRACE ))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index59_1);
				if (s >= 0) return s;
				break;
			case 1:
				int LA59_2 = input.LA(1);


				int index59_2 = input.Index;
				input.Rewind();
				s = -1;
				if ((( input.LA(1) == FUNCTION ))) {s = 39;}

				else if ((true)) {s = 3;}


				input.Seek(index59_2);
				if (s >= 0) return s;
				break;
		}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 59, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA60 : DFA
	{
		private const string DFA60_eotS =
			"\xF\xFFFF";
		private const string DFA60_eofS =
			"\x4\xFFFF\x1\x3\xA\xFFFF";
		private const string DFA60_minS =
			"\x1\x5\x3\xFFFF\x1\x5\xA\xFFFF";
		private const string DFA60_maxS =
			"\x1\xA7\x3\xFFFF\x1\xAA\xA\xFFFF";
		private const string DFA60_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\xFFFF\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1"+
			"\x9\x1\xB\x1\xC\x1\xD\x1\xA";
		private const string DFA60_specialS =
			"\xF\xFFFF}>";
		private static readonly string[] DFA60_transitionS =
			{
				"\x1\x3\x8\xFFFF\x1\x8\xE\xFFFF\x1\x7\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\x2"+
				"\xFFFF\x1\x6\x5\xFFFF\x1\x3\x9\xFFFF\x1\x3\x4\xFFFF\x1\x6\x2\xFFFF\x1"+
				"\x3\x5\xFFFF\x1\x3\x1\x5\x3\xFFFF\x1\x3\x3\xFFFF\x1\x3\x1\xFFFF\x1\x4"+
				"\x5\xFFFF\x2\x3\x3\xFFFF\x1\x3\xE\xFFFF\x2\x3\x1\xFFFF\x1\x3\x5\xFFFF"+
				"\x1\x3\xD\xFFFF\x1\x9\x3\xFFFF\x1\x3\x1\xFFFF\x1\x2\xA\xFFFF\x1\x3\x2"+
				"\xFFFF\x1\xB\x2\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\xC\x2\xFFFF\x1\x3\x1\xD"+
				"\x1\x3\x2\xFFFF\x1\x1\x1\x3\x2\xFFFF\x1\x6\x1\xA",
				"",
				"",
				"",
				"\x4\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\xE\x1\x3\x5\xFFFF\x1\x3\x2\xFFFF\x2"+
				"\x3\x1\xFFFF\x1\x3\x7\xFFFF\x2\x3\xF\xFFFF\x2\x3\x6\xFFFF\x3\x3\x9\xFFFF"+
				"\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x2\x3\x1\xFFFF\x5\x3\x4\xFFFF\x1\x3\x2"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\xC\xFFFF\x2\x3\x7\xFFFF\x4\x3\x1\xFFFF\x4"+
				"\x3\x3\xFFFF\x2\x3\x16\xFFFF\x2\x3",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA60_eot = DFA.UnpackEncodedString(DFA60_eotS);
		private static readonly short[] DFA60_eof = DFA.UnpackEncodedString(DFA60_eofS);
		private static readonly char[] DFA60_min = DFA.UnpackEncodedStringToUnsignedChars(DFA60_minS);
		private static readonly char[] DFA60_max = DFA.UnpackEncodedStringToUnsignedChars(DFA60_maxS);
		private static readonly short[] DFA60_accept = DFA.UnpackEncodedString(DFA60_acceptS);
		private static readonly short[] DFA60_special = DFA.UnpackEncodedString(DFA60_specialS);
		private static readonly short[][] DFA60_transition;

		static DFA60()
		{
			int numStates = DFA60_transitionS.Length;
			DFA60_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA60_transition[i] = DFA.UnpackEncodedString(DFA60_transitionS[i]);
			}
		}

		public DFA60( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 60;
			this.eot = DFA60_eot;
			this.eof = DFA60_eof;
			this.min = DFA60_min;
			this.max = DFA60_max;
			this.accept = DFA60_accept;
			this.special = DFA60_special;
			this.transition = DFA60_transition;
		}

		public override string Description { get { return "1489:1: statementTail returns [SyntaxNode value] : (vst= variableStatement |est= emptyStatement |exst= expressionStatement |ifst= ifStatement |itst= iterationStatement |cost= continueStatement |brst= breakStatement |rst= returnStatement |wist= withStatement |last= labelledStatement |swst= switchStatement |thst= throwStatement |trst= tryStatement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA91 : DFA
	{
		private const string DFA91_eotS =
			"\x27\xFFFF";
		private const string DFA91_eofS =
			"\x27\xFFFF";
		private const string DFA91_minS =
			"\x1\x5\x1\x0\x25\xFFFF";
		private const string DFA91_maxS =
			"\x1\xA7\x1\x0\x25\xFFFF";
		private const string DFA91_acceptS =
			"\x2\xFFFF\x1\x2\x23\xFFFF\x1\x1";
		private const string DFA91_specialS =
			"\x1\xFFFF\x1\x0\x25\xFFFF}>";
		private static readonly string[] DFA91_transitionS =
			{
				"\x1\x2\x8\xFFFF\x1\x2\xE\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2"+
				"\xFFFF\x1\x2\x5\xFFFF\x1\x2\x9\xFFFF\x1\x2\x4\xFFFF\x1\x2\x2\xFFFF\x1"+
				"\x1\x5\xFFFF\x2\x2\x3\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x2\x5\xFFFF"+
				"\x2\x2\x3\xFFFF\x1\x2\xE\xFFFF\x2\x2\x1\xFFFF\x1\x2\x5\xFFFF\x1\x2\xD"+
				"\xFFFF\x1\x2\x3\xFFFF\x1\x2\x1\xFFFF\x1\x2\xA\xFFFF\x1\x2\x2\xFFFF\x1"+
				"\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x2\x2\xFFFF\x3\x2\x2\xFFFF\x2\x2\x2\xFFFF"+
				"\x2\x2",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA91_eot = DFA.UnpackEncodedString(DFA91_eotS);
		private static readonly short[] DFA91_eof = DFA.UnpackEncodedString(DFA91_eofS);
		private static readonly char[] DFA91_min = DFA.UnpackEncodedStringToUnsignedChars(DFA91_minS);
		private static readonly char[] DFA91_max = DFA.UnpackEncodedStringToUnsignedChars(DFA91_maxS);
		private static readonly short[] DFA91_accept = DFA.UnpackEncodedString(DFA91_acceptS);
		private static readonly short[] DFA91_special = DFA.UnpackEncodedString(DFA91_specialS);
		private static readonly short[][] DFA91_transition;

		static DFA91()
		{
			int numStates = DFA91_transitionS.Length;
			DFA91_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA91_transition[i] = DFA.UnpackEncodedString(DFA91_transitionS[i]);
			}
		}

		public DFA91( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 91;
			this.eot = DFA91_eot;
			this.eof = DFA91_eof;
			this.min = DFA91_min;
			this.max = DFA91_max;
			this.accept = DFA91_accept;
			this.special = DFA91_special;
			this.transition = DFA91_transition;
		}

		public override string Description { get { return "2213:1: sourceElement returns [SyntaxNode value] options {k=1; } : ({...}?func= functionDeclaration |stat= statement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition91(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA91_1 = input.LA(1);


				int index91_1 = input.Index;
				input.Rewind();
				s = -1;
				if ((( input.LA(1) == FUNCTION ))) {s = 38;}

				else if ((true)) {s = 2;}


				input.Seek(index91_1);
				if (s >= 0) return s;
				break;
		}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 91, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _reservedWord_in_token1792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_token1797 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _punctuator_in_token1802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_token1807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_token1812 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _keyword_in_reservedWord1825 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _futureReservedWord_in_reservedWord1830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_reservedWord1835 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_reservedWord1840 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_keyword1854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_futureReservedWord1989 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_punctuator2274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_literal2532 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _booleanLiteral_in_literal2541 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_literal2550 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_literal2559 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RegularExpressionLiteral_in_literal2569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_booleanLiteral2586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_booleanLiteral2593 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DecimalLiteral_in_numericLiteral2804 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OctalIntegerLiteral_in_numericLiteral2813 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _HexIntegerLiteral_in_numericLiteral2822 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THIS_in_primaryExpression3236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_primaryExpression3245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_primaryExpression3254 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression3263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression3272 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_primaryExpression3281 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_primaryExpression3285 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_primaryExpression3288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_arrayLiteral3327 = new BitSet(new ulong[]{0x4040100A08000020UL,0x400416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _arrayItem_in_arrayLiteral3347 = new BitSet(new ulong[]{0x8000000UL,0x4000000000000000UL});
		public static readonly BitSet _COMMA_in_arrayLiteral3393 = new BitSet(new ulong[]{0x4040100A08000020UL,0x400416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _arrayItem_in_arrayLiteral3397 = new BitSet(new ulong[]{0x8000000UL,0x4000000000000000UL});
		public static readonly BitSet _RBRACK_in_arrayLiteral3451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_arrayItem3475 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_objectLiteral3546 = new BitSet(new ulong[]{0x100000000000UL,0x2004000000008010UL,0x800000UL});
		public static readonly BitSet _propertyAssignment_in_objectLiteral3560 = new BitSet(new ulong[]{0x8000000UL,0x2000000000000000UL});
		public static readonly BitSet _COMMA_in_objectLiteral3576 = new BitSet(new ulong[]{0x100000000000UL,0x4000000008010UL,0x800000UL});
		public static readonly BitSet _propertyAssignment_in_objectLiteral3590 = new BitSet(new ulong[]{0x8000000UL,0x2000000000000000UL});
		public static readonly BitSet _RBRACE_in_objectLiteral3620 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyFunctionAssignment_in_propertyAssignment3646 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyValueAssignment_in_propertyAssignment3671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _accessor_in_propertyFunctionAssignment3719 = new BitSet(new ulong[]{0x100000000000UL,0x4000000008010UL,0x800000UL});
		public static readonly BitSet _propertyName_in_propertyFunctionAssignment3741 = new BitSet(new ulong[]{0x0UL,0x4200000UL});
		public static readonly BitSet _formalParameterList_in_propertyFunctionAssignment3791 = new BitSet(new ulong[]{0x0UL,0x4200000UL});
		public static readonly BitSet _functionBody_in_propertyFunctionAssignment3836 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_propertyValueAssignment3888 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_propertyValueAssignment3908 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_propertyValueAssignment3920 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_accessor3960 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_propertyName3986 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_propertyName3995 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _numericLiteral_in_propertyName4004 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_memberExpression4030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionExpression_in_memberExpression4039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments4075 = new BitSet(new ulong[]{0x4040100A00000020UL,0x800416000460A210UL,0x8A2820012UL});
		public static readonly BitSet _argument_in_arguments4101 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x2UL});
		public static readonly BitSet _COMMA_in_arguments4147 = new BitSet(new ulong[]{0x4040100A00000020UL,0x800416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _argument_in_arguments4167 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_arguments4221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REF_in_argument4254 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_argument4271 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_generics4311 = new BitSet(new ulong[]{0x4040100A00000020UL,0x200416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_generics4322 = new BitSet(new ulong[]{0x8000000UL,0x2000000000000000UL});
		public static readonly BitSet _COMMA_in_generics4338 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_generics4346 = new BitSet(new ulong[]{0x8000000UL,0x2000000000000000UL});
		public static readonly BitSet _RBRACE_in_generics4367 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_leftHandSideExpression4414 = new BitSet(new ulong[]{0x4040100000000000UL,0x4120004608010UL,0x22800010UL});
		public static readonly BitSet _memberExpression_in_leftHandSideExpression4448 = new BitSet(new ulong[]{0x8000000002UL,0x4600000UL});
		public static readonly BitSet _generics_in_leftHandSideExpression4493 = new BitSet(new ulong[]{0x0UL,0x4200000UL});
		public static readonly BitSet _arguments_in_leftHandSideExpression4542 = new BitSet(new ulong[]{0x8000000002UL,0x4600000UL});
		public static readonly BitSet _LBRACK_in_leftHandSideExpression4577 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_leftHandSideExpression4581 = new BitSet(new ulong[]{0x0UL,0x4000000000000000UL});
		public static readonly BitSet _RBRACK_in_leftHandSideExpression4583 = new BitSet(new ulong[]{0x8000000002UL,0x4600000UL});
		public static readonly BitSet _DOT_in_leftHandSideExpression4620 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_leftHandSideExpression4624 = new BitSet(new ulong[]{0x8000000002UL,0x4600000UL});
		public static readonly BitSet _leftHandSideExpression_in_postfixExpression4672 = new BitSet(new ulong[]{0x200000002UL,0x200UL});
		public static readonly BitSet _postfixOperator_in_postfixExpression4687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_postfixOperator4717 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_postfixOperator4730 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression4755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryOperator_in_unaryExpression4764 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4768 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DELETE_in_unaryOperator4786 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VOID_in_unaryOperator4793 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TYPEOF_in_unaryOperator4800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INC_in_unaryOperator4807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_unaryOperator4814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ADD_in_unaryOperator4823 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUB_in_unaryOperator4832 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INV_in_unaryOperator4839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_unaryOperator4846 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4876 = new BitSet(new ulong[]{0x1000000002UL,0x280000000UL});
		public static readonly BitSet _MUL_in_multiplicativeExpression4894 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _DIV_in_multiplicativeExpression4908 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _MOD_in_multiplicativeExpression4921 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4935 = new BitSet(new ulong[]{0x1000000002UL,0x280000000UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression4973 = new BitSet(new ulong[]{0x22UL,0x0UL,0x20000UL});
		public static readonly BitSet _ADD_in_additiveExpression4992 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _SUB_in_additiveExpression5005 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression5019 = new BitSet(new ulong[]{0x22UL,0x0UL,0x20000UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression5058 = new BitSet(new ulong[]{0x2UL,0x0UL,0x1480UL});
		public static readonly BitSet _SHL_in_shiftExpression5077 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _SHR_in_shiftExpression5090 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _SHU_in_shiftExpression5103 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression5117 = new BitSet(new ulong[]{0x2UL,0x0UL,0x1480UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression5156 = new BitSet(new ulong[]{0x2UL,0x30000503UL});
		public static readonly BitSet _LT_in_relationalExpression5173 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _GT_in_relationalExpression5186 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _LTE_in_relationalExpression5199 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _GTE_in_relationalExpression5212 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _INSTANCEOF_in_relationalExpression5225 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _IN_in_relationalExpression5238 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression5252 = new BitSet(new ulong[]{0x2UL,0x30000503UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn5286 = new BitSet(new ulong[]{0x2UL,0x30000403UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn5303 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _GT_in_relationalExpressionNoIn5316 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _LTE_in_relationalExpressionNoIn5329 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _GTE_in_relationalExpressionNoIn5342 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _INSTANCEOF_in_relationalExpressionNoIn5355 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn5369 = new BitSet(new ulong[]{0x2UL,0x30000403UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression5405 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x20UL});
		public static readonly BitSet _EQ_in_equalityExpression5422 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _NEQ_in_equalityExpression5435 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _SAME_in_equalityExpression5448 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _NSAME_in_equalityExpression5461 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression5475 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x20UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn5509 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x20UL});
		public static readonly BitSet _EQ_in_equalityExpressionNoIn5526 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _NEQ_in_equalityExpressionNoIn5539 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _SAME_in_equalityExpressionNoIn5552 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _NSAME_in_equalityExpressionNoIn5565 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn5579 = new BitSet(new ulong[]{0x1000000000002UL,0x90000000000UL,0x20UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression5614 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_bitwiseANDExpression5627 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression5631 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5660 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _AND_in_bitwiseANDExpressionNoIn5673 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn5677 = new BitSet(new ulong[]{0x82UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression5708 = new BitSet(new ulong[]{0x2UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _XOR_in_bitwiseXORExpression5721 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression5725 = new BitSet(new ulong[]{0x2UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5756 = new BitSet(new ulong[]{0x2UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _XOR_in_bitwiseXORExpressionNoIn5769 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn5773 = new BitSet(new ulong[]{0x2UL,0x0UL,0x20000000000UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression5803 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _OR_in_bitwiseORExpression5816 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression5820 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5850 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _OR_in_bitwiseORExpressionNoIn5863 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn5867 = new BitSet(new ulong[]{0x2UL,0x400000000000UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression5901 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _LAND_in_logicalANDExpression5914 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression5918 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5947 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _LAND_in_logicalANDExpressionNoIn5960 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn5964 = new BitSet(new ulong[]{0x2UL,0x100000UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression5994 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _LOR_in_logicalORExpression6007 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression6011 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn6041 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _LOR_in_logicalORExpressionNoIn6054 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn6058 = new BitSet(new ulong[]{0x2UL,0x2000000UL});
		public static readonly BitSet _logicalORExpression_in_conditionalExpression6092 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _QUE_in_conditionalExpression6105 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression6109 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_conditionalExpression6114 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression6118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn6147 = new BitSet(new ulong[]{0x2UL,0x1000000000000000UL});
		public static readonly BitSet _QUE_in_conditionalExpressionNoIn6160 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn6164 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_conditionalExpressionNoIn6169 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn6173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression6220 = new BitSet(new ulong[]{0x2000000942UL,0x800500000000UL,0x40000042900UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression6267 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression6283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_assignmentOperator6318 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn6406 = new BitSet(new ulong[]{0x2000000942UL,0x800500000000UL,0x40000042900UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn6454 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn6470 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression6536 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _COMMA_in_expression6570 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_expression6586 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn6646 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _COMMA_in_expressionNoIn6680 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn6696 = new BitSet(new ulong[]{0x8000002UL});
		public static readonly BitSet _SEMIC_in_semic6749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_semic6754 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RBRACE_in_semic6759 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_semic6766 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MultiLineComment_in_semic6774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement6810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_statement6821 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementTail_in_statement6830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_statementTail6851 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyStatement_in_statementTail6860 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statementTail6869 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statementTail6878 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iterationStatement_in_statementTail6887 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statementTail6896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statementTail6905 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statementTail6914 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statementTail6923 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_statementTail6932 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statementTail6941 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statementTail6950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statementTail6959 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_block6998 = new BitSet(new ulong[]{0x4840104A20004020UL,0x200416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_block7024 = new BitSet(new ulong[]{0x4840104A20004020UL,0x200416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _RBRACE_in_block7059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_blockStatements7096 = new BitSet(new ulong[]{0x4840104A20004022UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _VAR_in_variableStatement7160 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclaration_in_variableStatement7164 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _COMMA_in_variableStatement7198 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclaration_in_variableStatement7202 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_variableStatement7237 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_variableDeclaration7267 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _ASSIGN_in_variableDeclaration7291 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpression_in_variableDeclaration7295 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_variableDeclarationNoIn7361 = new BitSet(new ulong[]{0x802UL});
		public static readonly BitSet _ASSIGN_in_variableDeclarationNoIn7385 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_variableDeclarationNoIn7389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_emptyStatement7444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionStatement7483 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_expressionStatement7485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifStatement7529 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_ifStatement7531 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_ifStatement7535 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_ifStatement7537 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_ifStatement7559 = new BitSet(new ulong[]{0x200000000002UL});
		public static readonly BitSet _ELSE_in_ifStatement7597 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_ifStatement7601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doStatement_in_iterationStatement7658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_iterationStatement7667 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_iterationStatement7677 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_doStatement7709 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_doStatement7713 = new BitSet(new ulong[]{0x0UL,0x0UL,0x4000000000UL});
		public static readonly BitSet _WHILE_in_doStatement7733 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_doStatement7735 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_doStatement7739 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_doStatement7741 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_doStatement7743 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whileStatement7782 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_whileStatement7784 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_whileStatement7788 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_whileStatement7790 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_whileStatement7812 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_forStatement7857 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_forStatement7867 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0xCA2820050UL});
		public static readonly BitSet _forControl_in_forStatement7879 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_forStatement7899 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_forStatement7921 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlVar_in_forControl7956 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlExpression_in_forControl7981 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forControlSemic_in_forControl8006 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_forControlVar8059 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forControlVar8063 = new BitSet(new ulong[]{0x8000000UL,0x100UL,0x40UL});
		public static readonly BitSet _IN_in_forControlVar8115 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_forControlVar8119 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_forControlVar8192 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forControlVar8196 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x40UL});
		public static readonly BitSet _SEMIC_in_forControlVar8264 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820050UL});
		public static readonly BitSet _expression_in_forControlVar8306 = new BitSet(new ulong[]{0x0UL,0x0UL,0x40UL});
		public static readonly BitSet _SEMIC_in_forControlVar8365 = new BitSet(new ulong[]{0x4040100A00000022UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_forControlVar8407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionNoIn_in_forControlExpression8493 = new BitSet(new ulong[]{0x0UL,0x100UL,0x40UL});
		public static readonly BitSet _IN_in_forControlExpression8542 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_forControlExpression8546 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_forControlExpression8597 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820050UL});
		public static readonly BitSet _expression_in_forControlExpression8639 = new BitSet(new ulong[]{0x0UL,0x0UL,0x40UL});
		public static readonly BitSet _SEMIC_in_forControlExpression8698 = new BitSet(new ulong[]{0x4040100A00000022UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_forControlExpression8740 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMIC_in_forControlSemic8823 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820050UL});
		public static readonly BitSet _expression_in_forControlSemic8849 = new BitSet(new ulong[]{0x0UL,0x0UL,0x40UL});
		public static readonly BitSet _SEMIC_in_forControlSemic8884 = new BitSet(new ulong[]{0x4040100A00000022UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_forControlSemic8910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_continueStatement8970 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800008000UL,0x40UL});
		public static readonly BitSet _Identifier_in_continueStatement9006 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_continueStatement9041 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_breakStatement9086 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800008000UL,0x40UL});
		public static readonly BitSet _Identifier_in_breakStatement9122 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_breakStatement9145 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnStatement9190 = new BitSet(new ulong[]{0x4040900A08000020UL,0x200416080460A210UL,0x8A2820050UL});
		public static readonly BitSet _expression_in_returnStatement9226 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_returnStatement9261 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withStatement9304 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_withStatement9306 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_withStatement9310 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_withStatement9312 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_withStatement9334 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switchStatement9377 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_switchStatement9379 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_switchStatement9383 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_switchStatement9385 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _LBRACE_in_switchStatement9405 = new BitSet(new ulong[]{0x400200000UL,0x2000000000000000UL});
		public static readonly BitSet _defaultClause_in_switchStatement9446 = new BitSet(new ulong[]{0x400200000UL,0x2000000000000000UL});
		public static readonly BitSet _caseClause_in_switchStatement9486 = new BitSet(new ulong[]{0x400200000UL,0x2000000000000000UL});
		public static readonly BitSet _RBRACE_in_switchStatement9521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseClause9559 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_caseClause9563 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_caseClause9565 = new BitSet(new ulong[]{0x4840104A20004022UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_caseClause9601 = new BitSet(new ulong[]{0x4840104A20004022UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _DEFAULT_in_defaultClause9665 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_defaultClause9667 = new BitSet(new ulong[]{0x4840104A20004022UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_defaultClause9703 = new BitSet(new ulong[]{0x4840104A20004022UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _Identifier_in_labelledStatement9769 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _COLON_in_labelledStatement9771 = new BitSet(new ulong[]{0x4840104A20004020UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _statement_in_labelledStatement9775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _THROW_in_throwStatement9820 = new BitSet(new ulong[]{0x4040100A00000020UL,0x416000460A210UL,0x8A2820010UL});
		public static readonly BitSet _expression_in_throwStatement9830 = new BitSet(new ulong[]{0x800008000000UL,0x2000000800000000UL,0x40UL});
		public static readonly BitSet _semic_in_throwStatement9832 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRY_in_tryStatement9874 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _block_in_tryStatement9878 = new BitSet(new ulong[]{0x200000000400000UL});
		public static readonly BitSet _catchClause_in_tryStatement9904 = new BitSet(new ulong[]{0x200000000400002UL});
		public static readonly BitSet _finallyClause_in_tryStatement9952 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _finallyClause_in_tryStatement10011 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_catchClause10069 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _LPAREN_in_catchClause10071 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_catchClause10075 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_catchClause10077 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _block_in_catchClause10087 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FINALLY_in_finallyClause10121 = new BitSet(new ulong[]{0x0UL,0x200000UL});
		public static readonly BitSet _block_in_finallyClause10125 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionDeclaration10178 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration10182 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _formalParameterList_in_functionDeclaration10199 = new BitSet(new ulong[]{0x0UL,0x4200000UL});
		public static readonly BitSet _functionBody_in_functionDeclaration10213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionExpression10256 = new BitSet(new ulong[]{0x0UL,0x4008000UL});
		public static readonly BitSet _Identifier_in_functionExpression10282 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _formalParameterList_in_functionExpression10319 = new BitSet(new ulong[]{0x0UL,0x4200000UL});
		public static readonly BitSet _functionBody_in_functionExpression10339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_formalParameterList10382 = new BitSet(new ulong[]{0x0UL,0x8000UL,0x2UL});
		public static readonly BitSet _Identifier_in_formalParameterList10408 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x2UL});
		public static readonly BitSet _COMMA_in_formalParameterList10454 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _Identifier_in_formalParameterList10458 = new BitSet(new ulong[]{0x8000000UL,0x0UL,0x2UL});
		public static readonly BitSet _RPAREN_in_formalParameterList10512 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_functionBody10533 = new BitSet(new ulong[]{0x4840104A20004020UL,0x200416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _sourceElement_in_functionBody10559 = new BitSet(new ulong[]{0x4840104A20004020UL,0x200416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _RBRACE_in_functionBody10594 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sourceElement_in_program10642 = new BitSet(new ulong[]{0x4840104A20004022UL,0x416000460A230UL,0xCCE6920051UL});
		public static readonly BitSet _functionDeclaration_in_sourceElement10716 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_sourceElement10727 = new BitSet(new ulong[]{0x2UL});

	}
	#endregion Follow sets
}

} // namespace  Jint.Parser 
